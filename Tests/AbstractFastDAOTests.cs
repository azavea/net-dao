// Copyright (c) 2004-2010 Azavea, Inc.
// 
// Permission is hereby granted, free of charge, to any person
// obtaining a copy of this software and associated documentation
// files (the "Software"), to deal in the Software without
// restriction, including without limitation the rights to use,
// copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the
// Software is furnished to do so, subject to the following
// conditions:
// 
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
// OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
// HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
// WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
// OTHER DEALINGS IN THE SOFTWARE.

using System;
using System.Collections.Generic;
using Azavea.Open.Common.Collections;
using Azavea.Open.DAO.Criteria;
using Azavea.Open.DAO.Criteria.Grouping;
using Azavea.Open.DAO.SQL;
using NUnit.Framework;
using Azavea.Open.Common;

namespace Azavea.Open.DAO.Tests
{
    /// <summary>
    /// This is a set of tests that you can extend when you create new FastDAO plugins.
    /// Uses SQL to double-check that things are correct in the data source, so only
    /// works with SQL data sources.
    /// </summary>
    public abstract class AbstractFastDAOTests
    {
        // If you modify this class or add tests, please add a version of each test
        // for a typed FastDAO and another for a DictionaryDAO.

        /// <exclude/>
        protected readonly IConnectionDescriptor _connDesc;

        /// <exclude/>
        protected readonly FastDAO<NameClass> _nameDAO;
        /// <exclude/>
        protected readonly DictionaryDao _nameDictDAO;
        /// <exclude/>
        protected readonly FastDAO<EnumClass> _enumDAO;
        /// <exclude/>
        protected readonly DictionaryDao _enumDictDAO;
        /// <exclude/>
        protected readonly FastDAO<BoolClass> _boolDAO;
        /// <exclude/>
        protected readonly DictionaryDao _boolDictDAO;
        /// <exclude/>
        protected readonly FastDAO<NullableClass> _nullDAO;
        /// <exclude/>
        protected readonly DictionaryDao _nullDictDAO;

        /// <exclude/>
        protected readonly Boolean _hasNativeBoolean;
        /// <exclude/>
        protected readonly Boolean _canGetAutoGeneratedID = true;
        /// <exclude/>
        protected readonly Boolean _canVerifyWithSQL = true;
        /// <exclude/>
        protected readonly Boolean _supportsGroupBy = true;
        /// <exclude/>
        protected readonly Boolean _expectNullsFirst = true;
        /// <exclude/>
        protected readonly Boolean _supportsTransactions = true;
        /// <exclude/>
        protected readonly Boolean _transactionsLockData;

        /// <exclude/>
        protected AbstractFastDAOTests(Config cfg, string configSection, bool hasNativeBoolean)
        {
            _connDesc = ConnectionDescriptor.LoadFromConfig(cfg, configSection);
            _nameDAO = new FastDAO<NameClass>(cfg, configSection);
            _nameDictDAO = new DictionaryDao("Azavea.Open.DAO.Tests.NameClass,Azavea.Open.DAO", cfg, configSection);
            _enumDAO = new FastDAO<EnumClass>(cfg, configSection);
            _enumDictDAO = new DictionaryDao("Azavea.Open.DAO.Tests.EnumClass,Azavea.Open.DAO", cfg, configSection);
            _boolDAO = new FastDAO<BoolClass>(cfg, configSection);
            _boolDictDAO = new DictionaryDao("Azavea.Open.DAO.Tests.BoolClass,Azavea.Open.DAO", cfg, configSection);
            _nullDAO = new FastDAO<NullableClass>(cfg, configSection);
            _nullDictDAO = new DictionaryDao("Azavea.Open.DAO.Tests.NullableClass,Azavea.Open.DAO", cfg, configSection);
            _hasNativeBoolean = hasNativeBoolean;
        }

        /// <exclude/>
        protected AbstractFastDAOTests(Config cfg, string configSection, bool hasNativeBoolean,
                                       bool canGetAutoIDs, bool canVerifyWithSQL)
            : this(cfg, configSection, hasNativeBoolean)
        {
            _canGetAutoGeneratedID = canGetAutoIDs;
            _canVerifyWithSQL = canVerifyWithSQL;
        }

        /// <exclude/>
        protected AbstractFastDAOTests(Config cfg, string configSection, bool hasNativeBoolean,
                                       bool canGetAutoIDs, bool canVerifyWithSQL, bool supportsGroupBy,
                                       bool expectNullsFirst, bool supportsTransactions)
            : this(cfg, configSection, hasNativeBoolean, canGetAutoIDs, canVerifyWithSQL,
                   supportsGroupBy, expectNullsFirst, supportsTransactions, false) { }

        /// <exclude/>
        protected AbstractFastDAOTests(Config cfg, string configSection, bool hasNativeBoolean,
                                       bool canGetAutoIDs, bool canVerifyWithSQL, bool supportsGroupBy,
                                       bool expectNullsFirst, bool supportsTransactions,
                                       bool transactionsLockData)
            : this(cfg, configSection, hasNativeBoolean, canGetAutoIDs, canVerifyWithSQL)
        {
            _supportsGroupBy = supportsGroupBy;
            _expectNullsFirst = expectNullsFirst;
            _supportsTransactions = supportsTransactions;
            _transactionsLockData = transactionsLockData;
        }

        /// <summary>
        /// For child classes whose data access layers implement IDaDdlLayer, this will drop
        /// and recreate all the tables used by this test.  Otherwise it will just truncate them.
        /// 
        /// It will then insert all rows needed for the tests.
        /// </summary>
        [TestFixtureSetUp]
        public void ResetAllTables()
        {
            ResetStoreHouse(_nameDAO.DataAccessLayer);
            ResetTable(_nameDAO.DataAccessLayer, _nameDAO.ClassMap);
            ResetTable(_enumDAO.DataAccessLayer, _enumDAO.ClassMap);
            ResetTable(_boolDAO.DataAccessLayer, _boolDAO.ClassMap);
            ResetTable(_nullDAO.DataAccessLayer, _nullDAO.ClassMap);
            InsertName(_nameDAO, "Michael", 1);
            InsertName(_nameDAO, "Rich", 2);
            InsertName(_nameDAO, "Keith", 3);
            InsertName(_nameDAO, "Rachel", 4);
            InsertName(_nameDAO, "Jeff", 5);
            InsertName(_nameDAO, "Megan", 6);
        }

        /// <summary>
        /// Utility method for deleting and recreating unit test databases, if possible.
        /// </summary>
        /// <param name="layer">The low-level data access layer object from a FastDAO.</param>
        private static void ResetStoreHouse(IDaLayer layer)
        {
            if (layer is IDaDdlLayer)
            {
                IDaDdlLayer ddlLayer = (IDaDdlLayer)layer;
                try
                {
                    ddlLayer.DeleteStoreHouse();
                    ddlLayer.CreateStoreHouse();
                }
                catch (NotImplementedException)
                {
                    // Ignore it if not implemented.
                }
            }
        }

        /// <summary>
        /// Utility method for dropping and recreating unit test tables.
        /// </summary>
        /// <param name="layer">The low-level data access layer object from a FastDAO.</param>
        /// <param name="classMap">The class mapping for the table to recreate.</param>
        public static void ResetTable(IDaLayer layer, ClassMapping classMap)
        {
            if (layer is IDaDdlLayer)
            {
                IDaDdlLayer ddlLayer = (IDaDdlLayer) layer;
                ddlLayer.DeleteStoreRoom(classMap);
                ddlLayer.CreateStoreRoom(classMap);
            }
            else
            {
                layer.Truncate(classMap);
            }
        }

        /// <exclude/>
        [Test]
        public void TestSimpleRead()
        {
            IList<NameClass> list = _nameDAO.Get();

            Assert.Greater(list.Count, 1, "Should be more than one name in the DB.");
        }

        /// <exclude/>
        [Test]
        public void TestEmptyNestedCriteria()
        {
            DaoCriteria emptyCrit = new DaoCriteria();
            DaoCriteria parentCrit = new DaoCriteria();
            parentCrit.Expressions.Add(new CriteriaExpression(emptyCrit));
            IList<NameClass> list1 = _nameDAO.Get();
            IList<NameClass> list2 = _nameDAO.Get(parentCrit);

            Assert.Greater(list1.Count, 1, "Should be more than one name in the DB.");
            Assert.AreEqual(list1.Count, list2.Count, "Empty nested criteria should produce the same results as no criteria.");
        }

        /// <exclude/>
        [Test]
        public void TestSimpleReadDictionary()
        {
            IList<CheckedDictionary<string,object>> list = _nameDictDAO.Get();

            Assert.Greater(list.Count, 1, "Should be more than one name in the DB.");
        }

        /// <exclude/>
        [Test]
        public void TestGetByPropertyInList()
        {
            DaoCriteria crit = new DaoCriteria();
            IList<object> names = new List<object>();
            names.Add("Michael");
            names.Add("Keith");
            crit.Expressions.Add(new PropertyInListExpression("Name", names));

            IList<NameClass> results = _nameDAO.Get(crit);

            Assert.AreEqual(2, results.Count, "Should have received two names, but got " + results.Count + ".");
        }

        /// <exclude/>
        [Test]
        public void TestGetByPropertyInListDictionary()
        {
            DaoCriteria crit = new DaoCriteria();
            IList<object> names = new List<object>();
            names.Add("Michael");
            names.Add("Keith");
            crit.Expressions.Add(new PropertyInListExpression("Name", names));

            IList<CheckedDictionary<string, object>> results = _nameDictDAO.Get(crit);

            Assert.AreEqual(2, results.Count, "Should have received two names, but got " + results.Count + ".");
        }

        /// <exclude/>
        [Test]
        public void TestSimpleInsert()
        {
            string nameToInsert = "Aaron";

            InsertName(_nameDAO, nameToInsert, 0);

            AssertOneName(_nameDAO, nameToInsert, "Checking inserted name");
        }

        /// <exclude/>
        [Test]
        public void TestSimpleInsertDictionary()
        {
            string nameToInsert = "AaronD";

            InsertName(_nameDictDAO, nameToInsert, 0);

            AssertOneName(_nameDictDAO, nameToInsert, "Checking inserted name");
        }

        /// <exclude/>
        [Test]
        public void TestBatchInsert()
        {
            string name1 = "Chuck";
            string name2 = "Charlie";

            NameClass someName1 = new NameClass();
            someName1.Name = name1;
            NameClass someName2 = new NameClass();
            someName2.Name = name2;

            _nameDAO.Insert(new NameClass[] {someName1, someName2});

            AssertOneName(_nameDAO, name1, "Checking inserted name1");
            AssertOneName(_nameDAO, name2, "Checking inserted name2");
        }

        /// <exclude/>
        [Test]
        public void TestBatchInsertDictionary()
        {
            string name1 = "ChuckD";
            string name2 = "CharlieD";

            CheckedDictionary<string, object> someName1 = new CheckedDictionary<string, object>();
            someName1["Name"] = name1;
            CheckedDictionary<string, object> someName2 = new CheckedDictionary<string, object>();
            someName2["Name"] = name2;

            _nameDictDAO.Insert(new CheckedDictionary<string, object>[] { someName1, someName2 });

            AssertOneName(_nameDictDAO, name1, "Checking inserted name1");
            AssertOneName(_nameDictDAO, name2, "Checking inserted name2");
        }

        private void TestInsertFindingGenerateIdHelper<T>(FastDAO<T> dao, string nameToInsert) where T : class, new()
        {
            if (!_canGetAutoGeneratedID)
            {
                Assert.Ignore("Autogenerated IDs cannot be retrieved for this data source.");
            }
            // Initialize with an ID that could not be the auto-generated ID.
            T someName = InsertName(dao, nameToInsert, -1, true);

            // It should have ID that is in the database.
            T someNameRetrieved = dao.GetFirst("Name", nameToInsert);
            Assert.AreEqual(GetNameId(someNameRetrieved), GetNameId(someName),
                "Original object didn't get autogenerated ID set on it.");
        }

        /// <exclude/>
        [Test]
        public void TestInsertFindingGeneratedId()
        {
            TestInsertFindingGenerateIdHelper(_nameDAO, "Leahcim");
        }

        /// <exclude/>
        [Test]
        public void TestInsertFindingGeneratedIdDictionary()
        {
            TestInsertFindingGenerateIdHelper(_nameDictDAO, "LeahcimD");
        }

        /// <exclude/>
        [Test]
        public void TestMultiInsert()
        {
            string nameToInsert = "Josh";
            string nameToInsert2 = "Reed";

            InsertName(_nameDAO, nameToInsert, 0);
            InsertName(_nameDAO, nameToInsert2, 0);

            DaoCriteria crit = new DaoCriteria();
            IList<object> names = new List<object>();
            names.Add(nameToInsert);
            names.Add(nameToInsert2);
            crit.Expressions.Add(new PropertyInListExpression("Name", names));

            IList<NameClass> results = _nameDAO.Get(crit);

            Assert.AreEqual(2, results.Count, "Expected 2 and only 2 results for query on new records.");

            Assert.AreEqual(nameToInsert, (results[0]).Name, "First returned name does not match expected value.");
            Assert.AreEqual(nameToInsert2, (results[1]).Name, "Second returned name does not match expected value.");
        }

        /// <exclude/>
        [Test]
        public void TestMultiInsertDictionary()
        {
            string nameToInsert = "JoshD";
            string nameToInsert2 = "ReedD";

            InsertName(_nameDictDAO, nameToInsert, 0);
            InsertName(_nameDictDAO, nameToInsert2, 0);
            
            DaoCriteria crit = new DaoCriteria();
            IList<object> names = new List<object>();
            names.Add(nameToInsert);
            names.Add(nameToInsert2);
            crit.Expressions.Add(new PropertyInListExpression("Name", names));

            IList<CheckedDictionary<string, object>> results = _nameDictDAO.Get(crit);

            Assert.AreEqual(2, results.Count, "Expected 2 and only 2 results for query on new records.");

            Assert.AreEqual(nameToInsert, (results[0])["Name"], "First returned name does not match expected value.");
            Assert.AreEqual(nameToInsert2, (results[1])["Name"], "Second returned name does not match expected value.");
        }

        /// <exclude/>
        [Test]
        public void TestSimpleUpdate()
        {
            string nameToInsert = "Carissa";
            string changed = "CarissaCHANGED";

            InsertName(_nameDAO, nameToInsert, 400);

            NameClass fromDBName = AssertOneName(_nameDAO, nameToInsert, "Inserting before updating");
            fromDBName.Name = changed;

            _nameDAO.Update(fromDBName);

            AssertOneName(_nameDAO, changed, GetNameId(fromDBName), "Checking updated name");
        }

        /// <exclude/>
        [Test]
        public void TestSimpleUpdateDictionary()
        {
            string nameToInsert = "CarissaD";
            string changed = "CarissaCHANGEDD";

            InsertName(_nameDictDAO, nameToInsert, 410);

            CheckedDictionary<string, object> fromDBName = AssertOneName(_nameDictDAO, nameToInsert, "Inserting before updating");
            fromDBName["Name"] = changed;

            _nameDictDAO.Update(fromDBName);

            AssertOneName(_nameDictDAO, changed, GetNameId(fromDBName), "Checking updated name");
        }

        /// <exclude/>
        [Test]
        public void TestBatchUpdate()
        {
            string name1 = "Carissa";
            string changed1 = "CarissaCHANGED";
            string name2 = "Carrie";
            string changed2 = "CarrieCHANGED";

            NameClass someName1 = new NameClass();
            someName1.ID = 401;
            someName1.Name = name1;
            NameClass someName2 = new NameClass();
            someName2.ID = 501;
            someName2.Name = name2;

            _nameDAO.Insert(new NameClass[] { someName1, someName2 });

            NameClass fromDBName1 = AssertOneName(_nameDAO, name1, "Inserting name1 before updating");
            fromDBName1.Name = changed1;

            NameClass fromDBName2 = AssertOneName(_nameDAO, name2, "Inserting name2 before updating");
            fromDBName2.Name = changed2;

            _nameDAO.Update(new NameClass[] { fromDBName1, fromDBName2 });

            AssertOneName(_nameDAO, changed1, fromDBName1.ID, "Checking name1 after updating");
            AssertOneName(_nameDAO, changed2, fromDBName2.ID, "Checking name1 after updating");
        }

        /// <exclude/>
        [Test]
        public void TestBatchUpdateDictionary()
        {
            string name1 = "CarissaD";
            string changed1 = "CarissaCHANGEDD";
            string name2 = "CarrieD";
            string changed2 = "CarrieCHANGEDD";

            CheckedDictionary<string, object> someName1 = new CheckedDictionary<string, object>();
            someName1["ID"] = 411;
            someName1["Name"] = name1;
            CheckedDictionary<string, object> someName2 = new CheckedDictionary<string, object>();
            someName2["ID"] = 511;
            someName2["Name"] = name2;

            _nameDictDAO.Insert(new CheckedDictionary<string, object>[] { someName1, someName2 });

            CheckedDictionary<string, object> fromDBName1 = AssertOneName(_nameDictDAO, name1, "Inserting name1 before updating");
            fromDBName1["Name"] = changed1;

            CheckedDictionary<string, object> fromDBName2 = AssertOneName(_nameDictDAO, name2, "Inserting name2 before updating");
            fromDBName2["Name"] = changed2;

            _nameDictDAO.Update(new CheckedDictionary<string, object>[] { fromDBName1, fromDBName2 });

            AssertOneName(_nameDictDAO, changed1, fromDBName1["ID"], "Checking name1 after updating");
            AssertOneName(_nameDictDAO, changed2, fromDBName2["ID"], "Checking name2 after updating");
        }

        private static void TestSimpleDeleteHelper<T>(FastDAO<T> dao) where T : class, new()
        {
            string nameToInsert = "Andrew";

            InsertName(dao, nameToInsert, 500);

            T fromDbName = AssertOneName(dao, nameToInsert, "Inserting before deleting");

            dao.Delete(fromDbName);

            AssertNoName(dao, GetNameId(fromDbName), "After delete");
        }
        /// <exclude/>
        [Test]
        public void TestSimpleDelete()
        {
            TestSimpleDeleteHelper(_nameDAO);
        }

        /// <exclude/>
        [Test]
        public void TestSimpleDeleteDictionary()
        {
            TestSimpleDeleteHelper(_nameDictDAO);
        }

        /// <exclude/>
        [Test]
        public void TestSimpleInsensitiveLike()
        {
            DaoCriteria criteria = new DaoCriteria();
            // Jeff is added to the names table
            LikeInsensitiveExpression ilike = new LikeInsensitiveExpression("Name", "JEFF");
            criteria.Expressions.Add(ilike);
            int count = _nameDAO.GetCount(criteria);

            Assert.AreEqual(1, count, "Case insensitive name was not found");
        }

        private void TestTransactionalInsertDeleteHelper<T>(FastDAO<T> dao, string name) where T : class, new()
        {
            if (!_supportsTransactions)
            {
                Assert.Ignore("This data source does not support transactions.");
            }
            if (!(dao.ConnDesc is ITransactionalConnectionDescriptor))
            {
                Assert.Fail("Attempting to test transactions, but the connection descriptor doesn't think it supports them.");
            }
            // Start by making sure our record doesn't exist.
            AssertNoName(dao, name, "Verifing record doesn't exist before inserting");
            // Start a transaction.
            ITransaction tx = ((ITransactionalConnectionDescriptor)dao.ConnDesc).BeginTransaction();
            // Now insert them on the transaction.
            InsertName(dao, tx, name, 0);
            // Verify the transaction connection CAN see them.
            AssertOneName(dao, tx, name, "Record inserted on transaction");
            if (!_transactionsLockData)
            {
                // Verify a non-transaction connection cannot see them yet, since they aren't committed.
                AssertNoName(dao, name, "Record hasn't been committed");
            }
            // Commit the transaction.
            tx.Commit();
            // Verify a non-transaction connection can now see the records.
            AssertOneName(dao, name, "Record has been committed");
            // Start a new transaction.
            tx = ((ITransactionalConnectionDescriptor)dao.ConnDesc).BeginTransaction();
            // Delete the record on the transaction.
            DaoCriteria crit = new DaoCriteria(new EqualExpression("Name", name));
            dao.Delete(tx, crit);
            // Verify the transaction connection cannot see it.
            AssertNoName(dao, tx, name, "Record has been deleted");
            if (!_transactionsLockData)
            {
                // Verify a non-transaction connection can still see it.
                AssertOneName(dao, name, "Deletion is not committed");
            }
            // Roll back the transaction.
            tx.Rollback();
            // Verify the rolled-back deleted record still exists.
            AssertOneName(dao, name, "Rolled back deletion");
        }
        /// <exclude/>
        [Test]
        public void TestTransactionalInsertDelete()
        {
            TestTransactionalInsertDeleteHelper(_nameDAO, "Trans");
        }

        /// <exclude/>
        [Test]
        public void TestTransactionalInsertDeleteDictionary()
        {
            TestTransactionalInsertDeleteHelper(_nameDictDAO, "TransD");
        }

        /// <exclude />
        [Test]
        public void TestGetCount()
        {
            DaoCriteria crit = new DaoCriteria();

            int count = _nameDAO.GetCount(crit);

            Assert.Greater(count, 1, "Should be more than one name in the DB.");
        }

        /// <exclude />
        [Test]
        public void TestGetCountDictionary()
        {
            DaoCriteria crit = new DaoCriteria();

            int count = _nameDictDAO.GetCount(crit);

            Assert.Greater(count, 1, "Should be more than one name in the DB.");
        }

        /// <exclude />
        [Test]
        public void TestGetCountWithSort()
        {
            DaoCriteria crit = new DaoCriteria();
            crit.Orders.Add(new SortOrder("Name", SortType.Asc));

            int count = _nameDAO.GetCount(crit);

            Assert.Greater(count, 1, "Should be more than one name in the DB.");
        }

        /// <exclude />
        [Test]
        public void TestGetCountWithSortDictionary()
        {
            DaoCriteria crit = new DaoCriteria();
            crit.Orders.Add(new SortOrder("Name"));

            int count = _nameDictDAO.GetCount(crit);

            Assert.Greater(count, 1, "Should be more than one name in the DB.");
        }

        /// <exclude/>
        [Test]
        public void TestEnums()
        {
            _enumDAO.Truncate();
            EnumClass testMe = new EnumClass();
            testMe.Enum1 = EnumTest.HERE;
            testMe.Enum2 = EnumTest.IS;
            _enumDAO.Insert(testMe);

            IList<EnumClass> enums = _enumDAO.Get();
            Assert.IsNotNull(enums, "Got null list.");
            Assert.AreEqual(1, enums.Count, "Should be one.");
            EnumClass queryResult = enums[0];
            Assert.AreEqual(testMe.Enum1, queryResult.Enum1, "Enum 1 was wrong.");
            Assert.AreEqual(testMe.Enum2, queryResult.Enum2, "Enum 2 was wrong.");

            // Now check the values in the DB are correct.
            if (_canVerifyWithSQL)
            {
                string strEnum = SqlConnectionUtilities.XSafeStringQuery((AbstractSqlConnectionDescriptor)_connDesc,
                                                                         "SELECT StringEnum FROM EnumTable", null);
                Assert.AreEqual(testMe.Enum1.ToString(), strEnum, "String enum stored wrong.");
                int intEnum = SqlConnectionUtilities.XSafeIntQuery((AbstractSqlConnectionDescriptor)_connDesc,
                                                                   "SELECT IntEnum FROM EnumTable", null);
                Assert.AreEqual((int)testMe.Enum2, intEnum, "Int enum stored wrong.");
            }
        }

        /// <exclude/>
        [Test]
        public void TestEnumsDictionary()
        {
            _enumDictDAO.Truncate();
            CheckedDictionary<string, object> testMe = new CheckedDictionary<string, object>();
            testMe["Enum1"] = EnumTest.AN;
            testMe["Enum2"] = EnumTest.ENUM;
            _enumDictDAO.Insert(testMe);

            IList<CheckedDictionary<string, object>> enums = _enumDictDAO.Get();
            Assert.IsNotNull(enums, "Got null list.");
            Assert.AreEqual(1, enums.Count, "Should be one.");
            CheckedDictionary<string, object> queryResult = enums[0];
            // DictionaryDAOs don't convert to any particular type, so you have to convert
            // when reading from them.
            Assert.AreEqual(testMe["Enum1"], Enum.Parse(typeof(EnumTest), queryResult["Enum1"].ToString()), "Enum 1 was wrong.");
            Assert.AreEqual(testMe["Enum2"], Enum.Parse(typeof(EnumTest), queryResult["Enum2"].ToString()), "Enum 2 was wrong.");

            // Now check the values in the DB are correct.
            if (_canVerifyWithSQL)
            {
                string strEnum = SqlConnectionUtilities.XSafeStringQuery((AbstractSqlConnectionDescriptor)_connDesc,
                                                                         "SELECT StringEnum FROM EnumTable", null);
                Assert.AreEqual(testMe["Enum1"].ToString(), strEnum, "String enum stored wrong.");
                int intEnum = SqlConnectionUtilities.XSafeIntQuery((AbstractSqlConnectionDescriptor)_connDesc,
                                                                   "SELECT IntEnum FROM EnumTable", null);
                Assert.AreEqual(Convert.ToInt32(testMe["Enum2"]), intEnum, "Int enum stored wrong.");
            }
        }

        /// <exclude/>
        [Test]
        public void TestBools()
        {
            _boolDAO.Truncate();
            BoolClass testMe = new BoolClass();
            testMe.ID = 100;
            testMe.BoolVal = true;
            _boolDAO.Insert(testMe);
            testMe = new BoolClass();
            testMe.ID = 200;
            testMe.BoolVal = false;
            _boolDAO.Insert(testMe);
            DaoCriteria crit = new DaoCriteria();
            SortOrder order = new SortOrder("ID", SortType.Asc);
            crit.Orders.Add(order);
            IList<BoolClass> bools = _boolDAO.Get(crit);
            Assert.IsNotNull(bools, "Got null list.");
            Assert.AreEqual(2, bools.Count, "Wrong number of records.");
            Assert.AreEqual(true, (bools[0]).BoolVal, "first was wrong.");
            Assert.AreEqual(false, (bools[1]).BoolVal, "second was wrong.");

            // Now check the values in the DB are correct.  Only need to if the DB
            // does not have a boolean type, and we're using a numeric type instead.
            if ((!_hasNativeBoolean) && (_canVerifyWithSQL))
            {
                int maxBool = SqlConnectionUtilities.XSafeIntQuery((AbstractSqlConnectionDescriptor)_connDesc, "SELECT MAX(IntBool) FROM BoolTable", null);
                Assert.AreEqual(1, maxBool, "True should have mapped to 1.");
                int minBool = SqlConnectionUtilities.XSafeIntQuery((AbstractSqlConnectionDescriptor)_connDesc, "SELECT MIN(IntBool) FROM BoolTable", null);
                Assert.AreEqual(0, minBool, "False should have mapped to 0.");
            }
        }

        /// <exclude/>
        [Test]
        public void TestBoolsDictionary()
        {
            _boolDictDAO.Truncate();
            CheckedDictionary<string, object> testMe = new CheckedDictionary<string, object>();
            testMe["ID"] = 101;
            testMe["BoolVal"] = true;
            _boolDictDAO.Insert(testMe);
            testMe = new CheckedDictionary<string, object>();
            testMe["ID"] = 201;
            testMe["BoolVal"] = false;
            _boolDictDAO.Insert(testMe);
            DaoCriteria crit = new DaoCriteria();
            SortOrder order = new SortOrder("ID", SortType.Asc);
            crit.Orders.Add(order);
            IList<CheckedDictionary<string, object>> bools = _boolDictDAO.Get(crit);
            Assert.IsNotNull(bools, "Got null list.");
            Assert.AreEqual(2, bools.Count, "Wrong number of records.");
            // DictionaryDAOs don't convert to any particular type, so you have to convert
            // when reading from them.
            Assert.AreEqual(true, Convert.ToBoolean((bools[0])["BoolVal"]), "first was wrong.");
            Assert.AreEqual(false, Convert.ToBoolean((bools[1])["BoolVal"]), "second was wrong.");

            // Now check the values in the DB are correct.  Only need to if the DB
            // does not have a boolean type, and we're using a numeric type instead.
            if ((!_hasNativeBoolean) && (_canVerifyWithSQL))
            {
                int maxBool = SqlConnectionUtilities.XSafeIntQuery((AbstractSqlConnectionDescriptor)_connDesc, "SELECT MAX(IntBool) FROM BoolTable", null);
                Assert.AreEqual(1, maxBool, "True should have mapped to 1.");
                int minBool = SqlConnectionUtilities.XSafeIntQuery((AbstractSqlConnectionDescriptor)_connDesc, "SELECT MIN(IntBool) FROM BoolTable", null);
                Assert.AreEqual(0, minBool, "False should have mapped to 0.");
            }
        }

        ///<exclude/>
        [Test]
        public void TestNullables()
        {
            PrepNullableTable();
            DaoCriteria crit = new DaoCriteria();
            SortOrder order = new SortOrder("ID", SortType.Asc);
            crit.Orders.Add(order);
            DateTime xDate = new DateTime(2001, 1, 1);
            IList<NullableClass> objs = _nullDAO.Get(crit);
            AssertNullableResults(objs,
                new bool?[] { null, true, true, true, true },
                new int?[] { null, null, 123, 123, 123 },
                    new DateTime?[] { null, null, null, xDate, xDate },
                new float?[] { null, null, 5.56f, 4.56f, 3.56f });
        }
        ///<exclude/>
        [Test]
        public void TestNullablesDictionary()
        {
            PrepNullDictTable();
            DaoCriteria crit = new DaoCriteria();
            SortOrder order = new SortOrder("ID", SortType.Asc);
            crit.Orders.Add(order);
            IList<CheckedDictionary<string, object>> objs = _nullDictDAO.Get(crit);
            Assert.IsNotNull(objs, "Got null list.");
            Assert.AreEqual(5, objs.Count, "Wrong number of records.");
            Assert.AreEqual(null, (objs[0])["BoolVal"], "first bool was wrong.");
            object trueVal = true;
            if (!_hasNativeBoolean)
            {
                trueVal = 1;
            }
            Assert.AreEqual(trueVal, (objs[1])["BoolVal"], "second bool was wrong.");
            Assert.AreEqual(trueVal, (objs[2])["BoolVal"], "third bool was wrong.");
            Assert.AreEqual(trueVal, (objs[3])["BoolVal"], "fourth bool was wrong.");
            Assert.AreEqual(trueVal, (objs[4])["BoolVal"], "fifth bool was wrong.");
            Assert.AreEqual(null, (objs[0])["IntVal"], "first int was wrong.");
            Assert.AreEqual(null, (objs[1])["IntVal"], "second int was wrong.");
            Assert.AreEqual(123, (objs[2])["IntVal"], "third int was wrong.");
            Assert.AreEqual(123, (objs[3])["IntVal"], "fourth int was wrong.");
            Assert.AreEqual(123, (objs[4])["IntVal"], "fifth int was wrong.");
            Assert.AreEqual(null, (objs[0])["DateVal"], "first date was wrong.");
            Assert.AreEqual(null, (objs[1])["DateVal"], "second date was wrong.");
            Assert.AreEqual(null, (objs[2])["DateVal"], "third date was wrong.");
            Assert.AreEqual(new DateTime(2001, 1, 1), (objs[3])["DateVal"], "fourth date was wrong.");
            Assert.AreEqual(new DateTime(2001, 1, 1), (objs[4])["DateVal"], "fifth date was wrong.");
            Assert.AreEqual(null, (objs[0])["FloatVal"], "first float was wrong.");
            Assert.AreEqual(null, (objs[1])["FloatVal"], "second float was wrong.");
            // Since this is a dictionary and doesn't lend typing to the variable, it may
            // come back as a double from the database, resulting in minor precision shifts.
            Assert.Greater(Convert.ToDouble((objs[2])["FloatVal"]), 5.55999, "third float was wrong.");
            Assert.Less(Convert.ToDouble((objs[2])["FloatVal"]), 5.56001, "third float was wrong.");
            Assert.Greater(Convert.ToDouble((objs[3])["FloatVal"]), 4.55999, "fourth float was wrong.");
            Assert.Less(Convert.ToDouble((objs[3])["FloatVal"]), 4.56001, "fourth float was wrong.");
            Assert.Greater(Convert.ToDouble((objs[4])["FloatVal"]), 3.55999, "fifth float was wrong.");
            Assert.Less(Convert.ToDouble((objs[4])["FloatVal"]), 3.56001, "fifth float was wrong.");
        }
        ///<exclude/>
        [Test]
        public void TestSortOnNull()
        {
            PrepNullableTable();
            DaoCriteria crit = new DaoCriteria();
            crit.Orders.Add(new SortOrder("FloatVal", SortType.Asc));
            crit.Orders.Add(new SortOrder("BoolVal", SortType.Asc));
            IList<NullableClass> objs = _nullDAO.Get(crit);
            DateTime xDate = new DateTime(2001, 1, 1);
            if (_expectNullsFirst)
            {
                AssertNullableResults(objs,
                    new bool?[]     { null, true, true,  true,  true },
                    new int?[]      { null, null, 123,   123,   123 },
                    new DateTime?[] { null, null, xDate, xDate, null },
                    new float?[]    { null, null, 3.56f, 4.56f, 5.56f });
            }
            else
            {
                AssertNullableResults(objs,
                    new bool?[]     { true, true, true, true, null },
                    new int?[]      { 123, 123, 123, null, null },
                    new DateTime?[] { xDate, xDate, null, null, null },
                    new float?[]    { 3.56f, 4.56f, 5.56f, null, null });
            }
        }

        private static void AssertNullableResults(IList<NullableClass> actuals,
            bool?[] expectedBools, int?[] expectedInts,
            DateTime?[] expectedDates, float?[] expectedFloats)
        {
            Assert.AreEqual(expectedBools.Length, expectedInts.Length, "Test error, int array doesn't match up.");
            Assert.AreEqual(expectedBools.Length, expectedDates.Length, "Test error, date array doesn't match up.");
            Assert.AreEqual(expectedBools.Length, expectedFloats.Length, "Test error, float array doesn't match up.");
            Assert.IsNotNull(actuals, "Got null list.");
            Assert.AreEqual(expectedBools.Length, actuals.Count, "Wrong number of records.");
            for (int index = 0; index < expectedBools.Length; index++)
            {
                Assert.AreEqual(expectedBools[index], actuals[index].BoolVal, "Bool " + index + " was wrong.");
                Assert.AreEqual(expectedInts[index], actuals[index].IntVal, "Int " + index + " was wrong.");
                Assert.AreEqual(expectedDates[index], actuals[index].DateVal, "Date " + index + " was wrong.");
                Assert.AreEqual(expectedFloats[index], actuals[index].FloatVal, "Float " + index + " was wrong.");
            }
        }

        ///<exclude/>
        [Test]
        public void TestGroupByOne()
        {
            if (!_supportsGroupBy)
            {
                Assert.Ignore("This data source does not support aggregation / group by.");
            }
            PrepNullableTable();
            List<AbstractGroupExpression> exprs = new List<AbstractGroupExpression>();
            exprs.Add(new MemberGroupExpression("IntVal"));
            DaoCriteria crit = new DaoCriteria();
            crit.Orders.Add(new GroupCountSortOrder());
            crit.Orders.Add(new SortOrder("IntVal", SortType.Asc));
            AssertGroupByOneAscResults(_nullDAO.GetCount(crit, exprs));
        }
        ///<exclude/>
        [Test]
        public void TestGroupByOneDesc()
        {
            if (!_supportsGroupBy)
            {
                Assert.Ignore("This data source does not support aggregation / group by.");
            }
            PrepNullableTable();
            List<AbstractGroupExpression> exprs = new List<AbstractGroupExpression>();
            exprs.Add(new MemberGroupExpression("IntVal"));
            DaoCriteria crit = new DaoCriteria();
            crit.Orders.Add(new GroupCountSortOrder(SortType.Desc));
            crit.Orders.Add(new SortOrder("IntVal", SortType.Asc));
            AssertGroupByOneDescResults(_nullDAO.GetCount(crit, exprs));
        }
        ///<exclude/>
        [Test]
        public void TestGroupByOneDictionary()
        {
            if (!_supportsGroupBy)
            {
                Assert.Ignore("This data source does not support aggregation / group by.");
            }
            PrepNullDictTable();
            List<AbstractGroupExpression> exprs = new List<AbstractGroupExpression>();
            exprs.Add(new MemberGroupExpression("IntVal"));
            DaoCriteria crit = new DaoCriteria();
            crit.Orders.Add(new GroupCountSortOrder());
            crit.Orders.Add(new SortOrder("IntVal", SortType.Asc));
            AssertGroupByOneAscResults(_nullDictDAO.GetCount(crit, exprs));
        }
        ///<exclude/>
        [Test]
        public void TestGroupByOneDescDictionary()
        {
            if (!_supportsGroupBy)
            {
                Assert.Ignore("This data source does not support aggregation / group by.");
            }
            PrepNullDictTable();
            List<AbstractGroupExpression> exprs = new List<AbstractGroupExpression>();
            exprs.Add(new MemberGroupExpression("IntVal"));
            DaoCriteria crit = new DaoCriteria();
            crit.Orders.Add(new GroupCountSortOrder(SortType.Desc));
            crit.Orders.Add(new SortOrder("IntVal", SortType.Asc));
            AssertGroupByOneDescResults(_nullDictDAO.GetCount(crit, exprs));
        }
        private static void AssertGroupByOneAscResults(IList<GroupCountResult> results)
        {
            Assert.IsNotNull(results, "Results should not be null.");
            DumpGroupResults(results);
            Assert.AreEqual(2, results.Count, "Wrong number of results.");
            // Regardless of whether we expect nulls first, we're first sorting by count.
            Assert.AreEqual(2, results[0].Count, "Wrong number of nulls.");
            Assert.AreEqual(null, results[0].GroupValues["IntVal"], "First result had wrong value.");
            Assert.AreEqual(3, results[1].Count, "Wrong number of 123s.");
            Assert.AreEqual(123, results[1].GroupValues["IntVal"], "Second result had wrong value.");
        }
        private static void AssertGroupByOneDescResults(IList<GroupCountResult> results)
        {
            Assert.IsNotNull(results, "Results should not be null.");
            DumpGroupResults(results);
            Assert.AreEqual(2, results.Count, "Wrong number of results.");
            // Regardless of whether we expect nulls first, we're first sorting by count.
            Assert.AreEqual(3, results[0].Count, "Wrong number of 123s.");
            Assert.AreEqual(123, results[0].GroupValues["IntVal"], "Second result had wrong value.");
            Assert.AreEqual(2, results[1].Count, "Wrong number of nulls.");
            Assert.AreEqual(null, results[1].GroupValues["IntVal"], "First result had wrong value.");
        }

        ///<exclude/>
        [Test]
        public void TestGroupByTwo()
        {
            if (!_supportsGroupBy)
            {
                Assert.Ignore("This data source does not support aggregation / group by.");
            }
            PrepNullableTable();
            List<AbstractGroupExpression> exprs = new List<AbstractGroupExpression>();
            exprs.Add(new MemberGroupExpression("IntVal"));
            exprs.Add(new MemberGroupExpression("BoolVal"));
            DaoCriteria crit = new DaoCriteria();
            crit.Orders.Add(new GroupCountSortOrder());
            crit.Orders.Add(new SortOrder("IntVal", SortType.Asc));
            crit.Orders.Add(new SortOrder("BoolVal", SortType.Asc));
            AssertGroupByTwoResults(_nullDAO.GetCount(crit, exprs), true);
        }
        ///<exclude/>
        [Test]
        public void TestGroupByTwoDictionary()
        {
            if (!_supportsGroupBy)
            {
                Assert.Ignore("This data source does not support aggregation / group by.");
            }
            PrepNullDictTable();
            List<AbstractGroupExpression> exprs = new List<AbstractGroupExpression>();
            exprs.Add(new MemberGroupExpression("IntVal"));
            exprs.Add(new MemberGroupExpression("BoolVal"));
            DaoCriteria crit = new DaoCriteria();
            crit.Orders.Add(new GroupCountSortOrder());
            crit.Orders.Add(new SortOrder("IntVal", SortType.Asc));
            crit.Orders.Add(new SortOrder("BoolVal", SortType.Asc));
            AssertGroupByTwoResults(_nullDictDAO.GetCount(crit, exprs), _hasNativeBoolean);
        }
        private void AssertGroupByTwoResults(IList<GroupCountResult> results, bool expectRealBool)
        {
            Assert.IsNotNull(results, "Results should not be null.");
            DumpGroupResults(results);
            Assert.AreEqual(3, results.Count, "Wrong number of results.");

            if (_expectNullsFirst)
            {
                Assert.AreEqual(1, results[0].Count, "Wrong number of null/nulls.");
                Assert.AreEqual(null, results[0].GroupValues["IntVal"], "First result had wrong int value.");
                Assert.AreEqual(null, results[0].GroupValues["BoolVal"], "First result had wrong bool value.");
                Assert.AreEqual(1, results[1].Count, "Wrong number of null/trues.");
                Assert.AreEqual(null, results[1].GroupValues["IntVal"], "Second result had wrong int value.");
                Assert.AreEqual((expectRealBool ? (object)true : 1), results[1].GroupValues["BoolVal"], "Second result had wrong bool value.");
                Assert.AreEqual(3, results[2].Count, "Wrong number of 123/trues.");
                Assert.AreEqual(123, results[2].GroupValues["IntVal"], "Third result had wrong int value.");
                Assert.AreEqual((expectRealBool ? (object)true : 1), results[2].GroupValues["BoolVal"], "Third result had wrong bool value.");
            }
            else
            {
                Assert.AreEqual(1, results[0].Count, "Wrong number of null/trues.");
                Assert.AreEqual(null, results[0].GroupValues["IntVal"], "First result had wrong int value.");
                Assert.AreEqual((expectRealBool ? (object)true : 1), results[0].GroupValues["BoolVal"], "First result had wrong bool value.");
                Assert.AreEqual(1, results[1].Count, "Wrong number of null/nulls.");
                Assert.AreEqual(null, results[1].GroupValues["IntVal"], "Second result had wrong int value.");
                Assert.AreEqual(null, results[1].GroupValues["BoolVal"], "Second result had wrong bool value.");
                Assert.AreEqual(3, results[2].Count, "Wrong number of 123/trues.");
                Assert.AreEqual(123, results[2].GroupValues["IntVal"], "Third result had wrong int value.");
                Assert.AreEqual((expectRealBool ? (object)true : 1), results[2].GroupValues["BoolVal"], "Third result had wrong bool value.");
            }
        }

        ///<exclude/>
        [Test]
        public void TestGroupByThree()
        {
            if (!_supportsGroupBy)
            {
                Assert.Ignore("This data source does not support aggregation / group by.");
            }
            PrepNullableTable();
            List<AbstractGroupExpression> exprs = new List<AbstractGroupExpression>();
            exprs.Add(new MemberGroupExpression("IntVal"));
            exprs.Add(new MemberGroupExpression("BoolVal"));
            exprs.Add(new MemberGroupExpression("DateVal"));
            DaoCriteria crit = new DaoCriteria();
            crit.Orders.Add(new GroupCountSortOrder());
            crit.Orders.Add(new SortOrder("IntVal", SortType.Asc));
            crit.Orders.Add(new SortOrder("BoolVal", SortType.Asc));
            crit.Orders.Add(new SortOrder("DateVal", SortType.Asc));
            AssertGroupByThreeResults(_nullDAO.GetCount(crit, exprs), true);
        }
        ///<exclude/>
        [Test]
        public void TestGroupByThreeDictionary()
        {
            if (!_supportsGroupBy)
            {
                Assert.Ignore("This data source does not support aggregation / group by.");
            }
            PrepNullDictTable();
            List<AbstractGroupExpression> exprs = new List<AbstractGroupExpression>();
            exprs.Add(new MemberGroupExpression("IntVal"));
            exprs.Add(new MemberGroupExpression("BoolVal"));
            exprs.Add(new MemberGroupExpression("DateVal"));
            DaoCriteria crit = new DaoCriteria();
            crit.Orders.Add(new GroupCountSortOrder());
            crit.Orders.Add(new SortOrder("IntVal", SortType.Asc));
            crit.Orders.Add(new SortOrder("BoolVal", SortType.Asc));
            crit.Orders.Add(new SortOrder("DateVal", SortType.Asc));
            AssertGroupByThreeResults(_nullDictDAO.GetCount(crit, exprs), _hasNativeBoolean);
        }
        private void AssertGroupByThreeResults(IList<GroupCountResult> results, bool expectRealBool)
        {
            Assert.IsNotNull(results, "Results should not be null.");
            DumpGroupResults(results);
            Assert.AreEqual(4, results.Count, "Wrong number of results.");

            if (_expectNullsFirst)
            {
                Assert.AreEqual(1, results[0].Count, "Wrong number of null/nulls.");
                Assert.AreEqual(null, results[0].GroupValues["IntVal"], "First result had wrong int value.");
                Assert.AreEqual(null, results[0].GroupValues["BoolVal"], "First result had wrong bool value.");
                Assert.AreEqual(null, results[0].GroupValues["DateVal"], "First result had wrong bool value.");
                Assert.AreEqual(1, results[1].Count, "Wrong number of null/trues.");
                Assert.AreEqual(null, results[1].GroupValues["IntVal"], "Second result had wrong int value.");
                Assert.AreEqual((expectRealBool ? (object)true : 1), results[1].GroupValues["BoolVal"], "Second result had wrong bool value.");
                Assert.AreEqual(null, results[1].GroupValues["DateVal"], "Second result had wrong bool value.");
                Assert.AreEqual(1, results[2].Count, "Wrong number of 123/trues.");
                Assert.AreEqual(123, results[2].GroupValues["IntVal"], "Third result had wrong int value.");
                Assert.AreEqual((expectRealBool ? (object)true : 1), results[2].GroupValues["BoolVal"], "Third result had wrong bool value.");
                Assert.AreEqual(null, results[2].GroupValues["DateVal"], "Third result had wrong bool value.");
                Assert.AreEqual(2, results[3].Count, "Wrong number of 123/trues.");
                Assert.AreEqual(123, results[3].GroupValues["IntVal"], "Fourth result had wrong int value.");
                Assert.AreEqual((expectRealBool ? (object)true : 1), results[3].GroupValues["BoolVal"], "Fourth result had wrong bool value.");
                Assert.AreEqual(new DateTime(2001, 1, 1), results[3].GroupValues["DateVal"],
                                "Fourth result had wrong bool value.");
            }
            else
            {
                Assert.AreEqual(1, results[0].Count, "Wrong number of 123/true/nulls.");
                Assert.AreEqual(123, results[0].GroupValues["IntVal"], "First result had wrong int value.");
                Assert.AreEqual((expectRealBool ? (object)true : 1), results[0].GroupValues["BoolVal"], "First result had wrong bool value.");
                Assert.AreEqual(null, results[0].GroupValues["DateVal"], "First result had wrong bool value.");
                Assert.AreEqual(1, results[1].Count, "Wrong number of null/true/nulls.");
                Assert.AreEqual(null, results[1].GroupValues["IntVal"], "Second result had wrong int value.");
                Assert.AreEqual((expectRealBool ? (object)true : 1), results[1].GroupValues["BoolVal"], "Second result had wrong bool value.");
                Assert.AreEqual(null, results[1].GroupValues["DateVal"], "Second result had wrong bool value.");
                Assert.AreEqual(1, results[2].Count, "Wrong number of null/null/nulls.");
                Assert.AreEqual(null, results[2].GroupValues["IntVal"], "Third result had wrong int value.");
                Assert.AreEqual(null, results[2].GroupValues["BoolVal"], "Third result had wrong bool value.");
                Assert.AreEqual(null, results[2].GroupValues["DateVal"], "Third result had wrong bool value.");
                Assert.AreEqual(2, results[3].Count, "Wrong number of 123/true/Dates.");
                Assert.AreEqual(123, results[3].GroupValues["IntVal"], "Fourth result had wrong int value.");
                Assert.AreEqual((expectRealBool ? (object)true : 1), results[3].GroupValues["BoolVal"], "Fourth result had wrong bool value.");
                Assert.AreEqual(new DateTime(2001, 1, 1), results[3].GroupValues["DateVal"],
                                "Fourth result had wrong bool value.");
            }
        }

        /// <exclude/>
        [Test]
        public void TestEnumInAndNotInList()
        {
            _enumDAO.Truncate();
            EnumClass test = new EnumClass();
            test.Enum1 = EnumTest.HERE;
            test.Enum2 = EnumTest.IS;
            _enumDAO.Insert(test);
            DaoCriteria crit = new DaoCriteria(new PropertyInListExpression("Enum1",
                new EnumTest[] { EnumTest.HERE }));
            Assert.AreEqual(1, _enumDAO.GetCount(crit), "Should be 1 row matching IN LIST.");
            crit = new DaoCriteria(new PropertyInListExpression("Enum1",
                new EnumTest[] { EnumTest.HERE }, false));
            Assert.AreEqual(0, _enumDAO.GetCount(crit), "Should be no rows matching NOT IN LIST.");
        }

        private static void DumpGroupResults(IEnumerable<GroupCountResult> results)
        {
            foreach (GroupCountResult result in results)
            {
                Console.WriteLine(result.Count + StringHelper.Join(result.GroupValues));
            }
        }

        private void PrepNullableTable()
        {
            _nullDAO.Truncate();
            NullableClass testMe = new NullableClass();
            testMe.ID = 100;
            _nullDAO.Insert(testMe);
            testMe.ID = 101;
            testMe.BoolVal = true;
            _nullDAO.Insert(testMe);
            testMe.ID = 102;
            testMe.IntVal = 123;
            testMe.FloatVal = (float)5.56;
            _nullDAO.Insert(testMe);
            testMe.ID = 103;
            testMe.FloatVal = (float)4.56;
            DateTime testDate = new DateTime(2001, 1, 1);
            testMe.DateVal = testDate;
            _nullDAO.Insert(testMe);
            testMe.ID = 104;
            testMe.FloatVal = (float)3.56;
            _nullDAO.Insert(testMe);
        }

        private void PrepNullDictTable()
        {
            _nullDictDAO.Truncate();
            CheckedDictionary<string, object> testMe = new CheckedDictionary<string, object>();
            testMe["ID"] = 110;
            _nullDictDAO.Insert(testMe);
            testMe["ID"] = 111;
            testMe["BoolVal"] = true;
            _nullDictDAO.Insert(testMe);
            testMe["ID"] = 112;
            testMe["FloatVal"] = (float)5.56;
            testMe["IntVal"] = 123;
            _nullDictDAO.Insert(testMe);
            testMe["ID"] = 113;
            testMe["FloatVal"] = (float)4.56;
            DateTime testDate = new DateTime(2001, 1, 1);
            testMe["DateVal"] = testDate;
            _nullDictDAO.Insert(testMe);
            testMe["ID"] = 114;
            testMe["FloatVal"] = (float)3.56;
            _nullDictDAO.Insert(testMe);
        }

        #region Name helper methods
        // These methods are intended to stop having to cut-n-paste
        // every unit test to test both the class-based and dictionary-based DAOs.
        // The refactor is not yet complete, but the delete test is done.

        // ReSharper disable UnusedParameter.Local
        // The DAO is passed because it is the simplest way to get type info, not because we
        // actually need it.
        private static T MakeName<T>(FastDAO<T> dao, string name, int id) where T : class, new()
        // ReSharper restore UnusedParameter.Local
        {
            T retVal;
            if (typeof(T) == typeof(NameClass))
            {
                NameClass someName = new NameClass();
                someName.ID = id;
                someName.Name = name;
                retVal = (T)(object)someName;
            }
            else
            {
                CheckedDictionary<string, object> someName = new CheckedDictionary<string, object>();
                someName["ID"] = id;
                someName["Name"] = name;
                retVal = (T)(object)someName;
            }
            return retVal;
        }
        private static T InsertName<T>(FastDAO<T> dao, string name, int id) where T : class, new()
        {
            return InsertName(dao, null, name, id, false);
        }
        private static T InsertName<T>(FastDAO<T> dao, ITransaction tx, string name, int id) where T : class, new()
        {
            return InsertName(dao, tx, name, id, false);
        }
        private static T InsertName<T>(FastDAO<T> dao, string name, int id, bool setGeneratedId) where T : class, new()
        {
            return InsertName(dao, null, name, id, setGeneratedId);
        }
        private static T InsertName<T>(FastDAO<T> dao, ITransaction tx, string name, int id, bool setGeneratedId) where T : class, new()
        {
            T retVal = MakeName(dao, name, id);
            dao.Insert(tx, retVal, setGeneratedId);
            return retVal;
        }
        private static object GetNameId<T>(T name)
        {
            if (typeof(T) == typeof(NameClass))
            {
                return ((NameClass) (object) name).ID;
            }
            return ((CheckedDictionary<string, object>) (object) name)["ID"];
        }
        private static void AssertNoName<T>(IFastDaoReader<T> dao, string name, string desc) where T : class, new()
        {
            Assert.AreEqual(0, dao.Get("Name", name).Count, desc + " - expected 0 results for name = " + name + ".");
        }
        private static void AssertNoName<T>(IFastDaoReader<T> dao, ITransaction tx, string name, string desc) where T : class, new()
        {
            Assert.AreEqual(0, dao.Get(tx, "Name", name).Count, desc + " - expected 0 results for name = " + name + ".");
        }
        private static void AssertNoName<T>(IFastDaoReader<T> dao, object id, string desc) where T : class, new()
        {
            Assert.AreEqual(0, dao.Get("ID", id).Count, desc + " - expected 0 results for id = " + id + ".");
        }
        private static T AssertOneName<T>(IFastDaoReader<T> dao, string name, string desc) where T : class, new()
        {
            return AssertOneName(dao.Get("Name", name), name, desc + " - name = " + name);
        }
        private static T AssertOneName<T>(IFastDaoReader<T> dao, ITransaction tx, string name, string desc) where T : class, new()
        {
            return AssertOneName(dao.Get(tx, "Name", name), name, desc + " - name = " + name);
        }
        private static T AssertOneName<T>(IFastDaoReader<T> dao, string name, object id, string desc) where T : class, new()
        {
            return AssertOneName(dao.Get("ID", id), name, desc + " - id = " + id);
        }
        private static T AssertOneName<T>(IList<T> results, string name, string desc) where T : class, new()
        {
            Assert.AreEqual(1, results.Count, desc + " - expected 1 and only 1 result for query.");
            T fromDbName = results[0];

            if (typeof(T) == typeof(NameClass))
            {
                Assert.AreEqual(name, ((NameClass)(object)fromDbName).Name, "Returned name does not match expected value.");
            }
            else
            {
                CheckedDictionary<string, object> nameDict = ((CheckedDictionary<string, object>) (object) fromDbName);
                Assert.IsTrue(nameDict.ContainsKey("ID"), "ID value is missing from read result.");
                Assert.IsTrue(nameDict.ContainsKey("Name"), "Name value is missing from read result.");
                Assert.AreEqual(name, nameDict["Name"], "Returned name does not match expected value.");
            }

            return fromDbName;
        }

        #endregion
    }

    /// <exclude/>
    public class NameClass
    {
        /// <exclude/>
        public int ID;
        /// <exclude/>
        public string Name;
        /// <exclude/>
        public NameClass()
        {
        }
        /// <exclude/>
        public NameClass(string name)
        {
            Name = name;
        }
    }

    /// <exclude/>
    public enum EnumTest
    {
        /// <exclude/>
        HERE,
        /// <exclude/>
        IS,
        /// <exclude/>
        AN,
        /// <exclude/>
        ENUM
    }

    /// <exclude/>
    public class EnumClass
    {
        /// <exclude/>
        public int ID;
        /// <exclude/>
        public EnumTest Enum1;
        /// <exclude/>
        public EnumTest Enum2;
    }

    /// <exclude/>
    public class BoolClass
    {
        /// <exclude/>
        public int ID;
        /// <exclude/>
        public bool BoolVal;
    }

    /// <exclude/>
    public class NullableClass
    {
        /// <exclude/>
        public int ID;
        /// <exclude/>
        public bool? BoolVal;
        /// <exclude/>
        public int? IntVal;
        /// <exclude/>
        public DateTime? DateVal;
        /// <exclude/>
        public float? FloatVal;
    }
}