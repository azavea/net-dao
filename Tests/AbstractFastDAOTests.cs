// Copyright (c) 2004-2010 Azavea, Inc.
// 
// Permission is hereby granted, free of charge, to any person
// obtaining a copy of this software and associated documentation
// files (the "Software"), to deal in the Software without
// restriction, including without limitation the rights to use,
// copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the
// Software is furnished to do so, subject to the following
// conditions:
// 
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
// OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
// HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
// WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
// OTHER DEALINGS IN THE SOFTWARE.

using System;
using System.Collections.Generic;
using Azavea.Open.Common.Collections;
using Azavea.Open.DAO.Criteria;
using Azavea.Open.DAO.Criteria.Grouping;
using Azavea.Open.DAO.SQL;
using NUnit.Framework;
using Azavea.Open.Common;

namespace Azavea.Open.DAO.Tests
{
    /// <summary>
    /// This is a set of tests that you can extend when you create new FastDAO plugins.
    /// Uses SQL to double-check that things are correct in the data source, so only
    /// works with SQL data sources.
    /// </summary>
    public abstract class AbstractFastDAOTests
    {
        // If you modify this class or add tests, please add a version of each test
        // for a typed FastDAO and another for a DictionaryDAO.

        /// <exclude/>
        protected readonly IConnectionDescriptor _connDesc;

        /// <exclude/>
        protected readonly FastDAO<NameClass> _nameDAO;
        /// <exclude/>
        protected readonly DictionaryDao _nameDictDAO;
        /// <exclude/>
        protected readonly FastDAO<EnumClass> _enumDAO;
        /// <exclude/>
        protected readonly DictionaryDao _enumDictDAO;
        /// <exclude/>
        protected readonly FastDAO<BoolClass> _boolDAO;
        /// <exclude/>
        protected readonly DictionaryDao _boolDictDAO;
        /// <exclude/>
        protected readonly FastDAO<NullableClass> _nullDAO;
        /// <exclude/>
        protected readonly DictionaryDao _nullDictDAO;

        /// <exclude/>
        protected readonly Boolean _hasNativeBoolean;
        /// <summary>
        /// SQL Server's "bit" type acts like a native boolean type in
        /// most respects, except it returns from queries as "1" or "0".
        /// </summary>
        protected readonly Boolean _nativeBooleanReturnsAsBool;
        /// <exclude/>
        protected readonly Boolean _canGetAutoGeneratedID = true;
        /// <exclude/>
        protected readonly Boolean _canVerifyWithSQL = true;
        /// <exclude/>
        protected readonly Boolean _supportsGroupBy = true;
        /// <exclude/>
        protected readonly Boolean _expectNullsFirst = true;

        /// <exclude/>
        protected AbstractFastDAOTests(Config cfg, string configSection, bool hasNativeBoolean)
        {
            _connDesc = ConnectionDescriptor.LoadFromConfig(cfg, configSection);
            _nameDAO = new FastDAO<NameClass>(cfg, configSection);
            _nameDictDAO = new DictionaryDao("Azavea.Open.DAO.Tests.NameClass,Azavea.Open.DAO", cfg, configSection);
            _enumDAO = new FastDAO<EnumClass>(cfg, configSection);
            _enumDictDAO = new DictionaryDao("Azavea.Open.DAO.Tests.EnumClass,Azavea.Open.DAO", cfg, configSection);
            _boolDAO = new FastDAO<BoolClass>(cfg, configSection);
            _boolDictDAO = new DictionaryDao("Azavea.Open.DAO.Tests.BoolClass,Azavea.Open.DAO", cfg, configSection);
            _nullDAO = new FastDAO<NullableClass>(cfg, configSection);
            _nullDictDAO = new DictionaryDao("Azavea.Open.DAO.Tests.NullableClass,Azavea.Open.DAO", cfg, configSection);
            _hasNativeBoolean = hasNativeBoolean;
        }

        /// <exclude/>
        protected AbstractFastDAOTests(Config cfg, string configSection, bool hasNativeBoolean,
                                       bool canGetAutoIDs, bool canVerifyWithSQL)
            : this(cfg, configSection, hasNativeBoolean)
        {
            _canGetAutoGeneratedID = canGetAutoIDs;
            _canVerifyWithSQL = canVerifyWithSQL;
        }

        /// <exclude/>
        protected AbstractFastDAOTests(Config cfg, string configSection, bool hasNativeBoolean,
                                       bool canGetAutoIDs, bool canVerifyWithSQL, bool supportsGroupBy,
                                       bool expectNullsFirst)
            : this(cfg, configSection, hasNativeBoolean, canGetAutoIDs, canVerifyWithSQL)
        {
            _supportsGroupBy = supportsGroupBy;
            _expectNullsFirst = expectNullsFirst;
        }
        /// <exclude/>
        protected AbstractFastDAOTests(Config cfg, string configSection, bool hasNativeBoolean,
                                       bool canGetAutoIDs, bool canVerifyWithSQL, bool supportsGroupBy,
                                       bool expectNullsFirst, bool nativeBoolReturnsAsBool)
            : this(cfg, configSection, hasNativeBoolean, canGetAutoIDs, canVerifyWithSQL,
            supportsGroupBy, expectNullsFirst)
        {
            _nativeBooleanReturnsAsBool = nativeBoolReturnsAsBool;
        }

        /// <exclude/>
        [Test]
        public void TestSimpleRead()
        {
            IList<NameClass> list = _nameDAO.Get();

            Assert.Greater(list.Count, 1, "Should be more than one name in the DB.");
        }

        /// <exclude/>
        [Test]
        public void TestEmptyNestedCriteria()
        {
            DaoCriteria emptyCrit = new DaoCriteria();
            DaoCriteria parentCrit = new DaoCriteria();
            parentCrit.Expressions.Add(new CriteriaExpression(emptyCrit));
            IList<NameClass> list1 = _nameDAO.Get();
            IList<NameClass> list2 = _nameDAO.Get(parentCrit);

            Assert.Greater(list1.Count, 1, "Should be more than one name in the DB.");
            Assert.AreEqual(list1.Count, list2.Count, "Empty nested criteria should produce the same results as no criteria.");
        }

        /// <exclude/>
        [Test]
        public void TestSimpleReadDictionary()
        {
            IList<CheckedDictionary<string,object>> list = _nameDictDAO.Get();

            Assert.Greater(list.Count, 1, "Should be more than one name in the DB.");
        }

        /// <exclude/>
        [Test]
        public void TestGetByPropertyInList()
        {
            DaoCriteria crit = new DaoCriteria();
            IList<object> names = new List<object>();
            names.Add("Michael");
            names.Add("Keith");
            crit.Expressions.Add(new PropertyInListExpression("Name", names));

            IList<NameClass> results = _nameDAO.Get(crit);

            Assert.AreEqual(2, results.Count, "Should have received two names, but got " + results.Count + ".");
        }

        /// <exclude/>
        [Test]
        public void TestGetByPropertyInListDictionary()
        {
            DaoCriteria crit = new DaoCriteria();
            IList<object> names = new List<object>();
            names.Add("Michael");
            names.Add("Keith");
            crit.Expressions.Add(new PropertyInListExpression("Name", names));

            IList<CheckedDictionary<string, object>> results = _nameDictDAO.Get(crit);

            Assert.AreEqual(2, results.Count, "Should have received two names, but got " + results.Count + ".");
        }

        /// <exclude/>
        [Test]
        public void TestSimpleInsert()
        {
            string nameToInsert = "Aaron";

            NameClass someName = new NameClass();
            someName.Name = nameToInsert;

            _nameDAO.Insert(someName);

            IList<NameClass> results = _nameDAO.Get("Name", nameToInsert);

            Assert.AreEqual(1, results.Count, "Expected 1 and only 1 result for query on new record.");

            Assert.AreEqual(nameToInsert, (results[0]).Name, "Returned name does not match expected value.");
        }

        /// <exclude/>
        [Test]
        public void TestSimpleInsertDictionary()
        {
            string nameToInsert = "AaronD";

            CheckedDictionary<string, object> someName = new CheckedDictionary<string, object>();
            someName["Name"] = nameToInsert;

            _nameDictDAO.Insert(someName);

            IList<CheckedDictionary<string, object>> results = _nameDictDAO.Get("Name", nameToInsert);

            Assert.AreEqual(1, results.Count, "Expected 1 and only 1 result for query on new record.");

            Assert.AreEqual(nameToInsert, (results[0])["Name"], "Returned name does not match expected value.");
        }

        /// <exclude/>
        [Test]
        public void TestBatchInsert()
        {
            string name1 = "Chuck";
            string name2 = "Charlie";

            NameClass someName1 = new NameClass();
            someName1.Name = name1;
            NameClass someName2 = new NameClass();
            someName2.Name = name2;

            _nameDAO.Insert(new NameClass[] {someName1, someName2});

            IList<NameClass> results = _nameDAO.Get("Name", name1);
            Assert.AreEqual(1, results.Count, "Expected 1 and only 1 result for query on name1.");
            Assert.AreEqual(name1, (results[0]).Name, "Returned name1 does not match expected value.");
            results = _nameDAO.Get("Name", name2);
            Assert.AreEqual(1, results.Count, "Expected 1 and only 1 result for query on name2.");
            Assert.AreEqual(name2, (results[0]).Name, "Returned name2 does not match expected value.");
        }

        /// <exclude/>
        [Test]
        public void TestBatchInsertDictionary()
        {
            string name1 = "ChuckD";
            string name2 = "CharlieD";

            CheckedDictionary<string, object> someName1 = new CheckedDictionary<string, object>();
            someName1["Name"] = name1;
            CheckedDictionary<string, object> someName2 = new CheckedDictionary<string, object>();
            someName2["Name"] = name2;

            _nameDictDAO.Insert(new CheckedDictionary<string, object>[] { someName1, someName2 });

            IList<CheckedDictionary<string, object>> results = _nameDictDAO.Get("Name", name1);
            Assert.AreEqual(1, results.Count, "Expected 1 and only 1 result for query on name1.");
            Assert.AreEqual(name1, (results[0])["Name"], "Returned name1 does not match expected value.");
            results = _nameDictDAO.Get("Name", name2);
            Assert.AreEqual(1, results.Count, "Expected 1 and only 1 result for query on name2.");
            Assert.AreEqual(name2, (results[0])["Name"], "Returned name2 does not match expected value.");
        }

        /// <exclude/>
        [Test]
        public void TestInsertFindingGeneratedId()
        {
            if (!_canGetAutoGeneratedID)
            {
                Assert.Ignore("Autogenerated IDs cannot be retrieved for this data source.");
            }
            const string nameToInsert = "Leahcim";
            NameClass someName = new NameClass();
            
            // First set an ID that could not be the auto-generated ID.
            someName.ID = -1;
            someName.Name = nameToInsert;
            
            _nameDAO.Insert(someName, true);

            // It should have ID that is in the database.
            NameClass someNameRetrieved = _nameDAO.GetFirst("Name", nameToInsert);
            Assert.AreEqual(someNameRetrieved.ID, someName.ID);
        }

        /// <exclude/>
        [Test]
        public void TestInsertFindingGeneratedIdDictionary()
        {
            if (!_canGetAutoGeneratedID)
            {
                Assert.Ignore("Autogenerated IDs cannot be retrieved for this data source.");
            }
            const string nameToInsert = "LeahcimD";
            CheckedDictionary<string, object> someName = new CheckedDictionary<string, object>();

            // First set an ID that could not be the auto-generated ID.
            someName["ID"] = -1;
            someName["Name"] = nameToInsert;

            _nameDictDAO.Insert(someName, true);

            // It should have ID that is in the database.
            CheckedDictionary<string, object> someNameRetrieved = _nameDictDAO.GetFirst("Name", nameToInsert);
            Assert.AreEqual(someNameRetrieved["ID"], someName["ID"]);
        }

        /// <exclude/>
        [Test]
        public void TestMultiInsert()
        {
            string nameToInsert = "Josh";
            string nameToInsert2 = "Reed";

            NameClass someName = new NameClass();
            someName.Name = nameToInsert;

            NameClass someName2 = new NameClass();
            someName2.Name = nameToInsert2;

            _nameDAO.Insert(someName);
            _nameDAO.Insert(someName2);

            DaoCriteria crit = new DaoCriteria();
            IList<object> names = new List<object>();
            names.Add(nameToInsert);
            names.Add(nameToInsert2);
            crit.Expressions.Add(new PropertyInListExpression("Name", names));

            IList<NameClass> results = _nameDAO.Get(crit);

            Assert.AreEqual(2, results.Count, "Expected 2 and only 2 results for query on new records.");

            Assert.AreEqual(nameToInsert, (results[0]).Name, "First returned name does not match expected value.");
            Assert.AreEqual(nameToInsert2, (results[1]).Name, "Second returned name does not match expected value.");
        }

        /// <exclude/>
        [Test]
        public void TestMultiInsertDictionary()
        {
            string nameToInsert = "JoshD";
            string nameToInsert2 = "ReedD";

            CheckedDictionary<string, object> someName1 = new CheckedDictionary<string, object>();
            someName1["Name"] = nameToInsert;

            CheckedDictionary<string, object> someName2 = new CheckedDictionary<string, object>();
            someName2["Name"] = nameToInsert2;

            _nameDictDAO.Insert(someName1);
            _nameDictDAO.Insert(someName2);
            
            DaoCriteria crit = new DaoCriteria();
            IList<object> names = new List<object>();
            names.Add(nameToInsert);
            names.Add(nameToInsert2);
            crit.Expressions.Add(new PropertyInListExpression("Name", names));

            IList<CheckedDictionary<string, object>> results = _nameDictDAO.Get(crit);

            Assert.AreEqual(2, results.Count, "Expected 2 and only 2 results for query on new records.");

            Assert.AreEqual(nameToInsert, (results[0])["Name"], "First returned name does not match expected value.");
            Assert.AreEqual(nameToInsert2, (results[1])["Name"], "Second returned name does not match expected value.");
        }

        /// <exclude/>
        [Test]
        public void TestSimpleUpdate()
        {
            string nameToInsert = "Carissa";
            string changed = "CarissaCHANGED";

            NameClass someName = new NameClass();
            someName.ID = 400;
            someName.Name = nameToInsert;

            _nameDAO.Insert(someName);

            IList<NameClass> results = _nameDAO.Get("Name", nameToInsert);

            Assert.AreEqual(1, results.Count, "Expected 1 and only 1 result for query on new record.");

            NameClass fromDBName = results[0];
            fromDBName.Name = changed;

            _nameDAO.Update(fromDBName);

            IList<NameClass> results2 = _nameDAO.Get("ID", fromDBName.ID);

            Assert.AreEqual(1, results2.Count, "Expected 1 and only 1 result for query on new record.");

            Assert.AreEqual(changed, (results2[0]).Name, "Returned name does not match expected value.");
        }

        /// <exclude/>
        [Test]
        public void TestSimpleUpdateDictionary()
        {
            string nameToInsert = "CarissaD";
            string changed = "CarissaCHANGEDD";

            CheckedDictionary<string, object> someName = new CheckedDictionary<string, object>();
            someName["ID"] = 410;
            someName["Name"] = nameToInsert;

            _nameDictDAO.Insert(someName);

            IList<CheckedDictionary<string, object>> results = _nameDictDAO.Get("Name", nameToInsert);

            Assert.AreEqual(1, results.Count, "Expected 1 and only 1 result for query on new record.");

            CheckedDictionary<string, object> fromDBName = results[0];
            fromDBName["Name"] = changed;

            _nameDictDAO.Update(fromDBName);

            IList<CheckedDictionary<string, object>> results2 = _nameDictDAO.Get("ID", fromDBName["ID"]);

            Assert.AreEqual(1, results2.Count, "Expected 1 and only 1 result for query on new record.");

            Assert.AreEqual(changed, (results2[0])["Name"], "Returned name does not match expected value.");
        }

        /// <exclude/>
        [Test]
        public void TestBatchUpdate()
        {
            string name1 = "Carissa";
            string changed1 = "CarissaCHANGED";
            string name2 = "Carrie";
            string changed2 = "CarrieCHANGED";

            NameClass someName1 = new NameClass();
            someName1.ID = 401;
            someName1.Name = name1;
            NameClass someName2 = new NameClass();
            someName2.ID = 501;
            someName2.Name = name2;

            _nameDAO.Insert(new NameClass[] { someName1, someName2 });

            IList<NameClass> results = _nameDAO.Get("Name", name1);
            Assert.AreEqual(1, results.Count, "Expected 1 and only 1 result for query on name1.");
            NameClass fromDBName1 = results[0];
            fromDBName1.Name = changed1;

            results = _nameDAO.Get("Name", name2);
            Assert.AreEqual(1, results.Count, "Expected 1 and only 1 result for query on name2.");
            NameClass fromDBName2 = results[0];
            fromDBName2.Name = changed2;

            _nameDAO.Update(new NameClass[] { fromDBName1, fromDBName2 });

            IList<NameClass> updateResults1 = _nameDAO.Get("ID", fromDBName1.ID);
            Assert.AreEqual(1, updateResults1.Count, "Expected 1 and only 1 result for query on updated name1.");
            Assert.AreEqual(changed1, (updateResults1[0]).Name, "Returned name1 does not match expected value.");
            IList<NameClass> updateResults2 = _nameDAO.Get("ID", fromDBName2.ID);
            Assert.AreEqual(1, updateResults2.Count, "Expected 1 and only 1 result for query on updated name2.");
            Assert.AreEqual(changed2, (updateResults2[0]).Name, "Returned name2 does not match expected value.");
        }

        /// <exclude/>
        [Test]
        public void TestBatchUpdateDictionary()
        {
            string name1 = "CarissaD";
            string changed1 = "CarissaCHANGEDD";
            string name2 = "CarrieD";
            string changed2 = "CarrieCHANGEDD";

            CheckedDictionary<string, object> someName1 = new CheckedDictionary<string, object>();
            someName1["ID"] = 411;
            someName1["Name"] = name1;
            CheckedDictionary<string, object> someName2 = new CheckedDictionary<string, object>();
            someName2["ID"] = 511;
            someName2["Name"] = name2;

            _nameDictDAO.Insert(new CheckedDictionary<string, object>[] { someName1, someName2 });

            IList<CheckedDictionary<string, object>> results = _nameDictDAO.Get("Name", name1);
            Assert.AreEqual(1, results.Count, "Expected 1 and only 1 result for query on name1.");
            CheckedDictionary<string, object> fromDBName1 = results[0];
            fromDBName1["Name"] = changed1;

            results = _nameDictDAO.Get("Name", name2);
            Assert.AreEqual(1, results.Count, "Expected 1 and only 1 result for query on name2.");
            CheckedDictionary<string, object> fromDBName2 = results[0];
            fromDBName2["Name"] = changed2;

            _nameDictDAO.Update(new CheckedDictionary<string, object>[] { fromDBName1, fromDBName2 });

            IList<CheckedDictionary<string, object>> updateResults1 = _nameDictDAO.Get("ID", fromDBName1["ID"]);
            Assert.AreEqual(1, updateResults1.Count, "Expected 1 and only 1 result for query on updated name1.");
            Assert.AreEqual(changed1, (updateResults1[0])["Name"], "Returned name1 does not match expected value.");
            IList<CheckedDictionary<string, object>> updateResults2 = _nameDictDAO.Get("ID", fromDBName2["ID"]);
            Assert.AreEqual(1, updateResults2.Count, "Expected 1 and only 1 result for query on updated name2.");
            Assert.AreEqual(changed2, (updateResults2[0])["Name"], "Returned name2 does not match expected value.");
        }

        /// <exclude/>
        [Test]
        public void TestSimpleDelete()
        {
            string nameToInsert = "Andrew";

            NameClass someName = new NameClass();
            someName.ID = 500;
            someName.Name = nameToInsert;

            _nameDAO.Insert(someName);

            IList<NameClass> results = _nameDAO.Get("Name", nameToInsert);
            Assert.AreEqual(1, results.Count, "Expected 1 and only 1 result for query on new record.");

            NameClass fromDbName = results[0];

            _nameDAO.Delete(fromDbName);

            results = _nameDAO.Get("ID", fromDbName.ID);

            Assert.AreEqual(0, results.Count, "Query after delete expected 0 results.");
        }

        /// <exclude/>
        [Test]
        public void TestSimpleDeleteDictionary()
        {
            string nameToInsert = "AndrewD";

            CheckedDictionary<string, object> someName = new CheckedDictionary<string, object>();
            someName["ID"] = 500;
            someName["Name"] = nameToInsert;

            _nameDictDAO.Insert(someName);

            IList<CheckedDictionary<string, object>> results = _nameDictDAO.Get("Name", nameToInsert);
            Assert.AreEqual(1, results.Count, "Expected 1 and only 1 result for query on new record.");

            CheckedDictionary<string, object> fromDbName = results[0];
            Assert.IsTrue(fromDbName.ContainsKey("ID"), "ID value is missing from read result.");

            _nameDictDAO.Delete(fromDbName);

            results = _nameDictDAO.Get("ID", fromDbName["ID"]);

            Assert.AreEqual(0, results.Count, "Query after delete expected 0 results.");
        }

        /// <exclude />
        [Test]
        public void TestGetCount()
        {
            DaoCriteria crit = new DaoCriteria();

            int count = _nameDAO.GetCount(crit);

            Assert.Greater(count, 1, "Should be more than one name in the DB.");
        }

        /// <exclude />
        [Test]
        public void TestGetCountDictionary()
        {
            DaoCriteria crit = new DaoCriteria();

            int count = _nameDictDAO.GetCount(crit);

            Assert.Greater(count, 1, "Should be more than one name in the DB.");
        }

        /// <exclude />
        [Test]
        public void TestGetCountWithSort()
        {
            DaoCriteria crit = new DaoCriteria();
            crit.Orders.Add(new SortOrder("Name", SortType.Asc));

            int count = _nameDAO.GetCount(crit);

            Assert.Greater(count, 1, "Should be more than one name in the DB.");
        }

        /// <exclude />
        [Test]
        public void TestGetCountWithSortDictionary()
        {
            DaoCriteria crit = new DaoCriteria();
            crit.Orders.Add(new SortOrder("Name"));

            int count = _nameDictDAO.GetCount(crit);

            Assert.Greater(count, 1, "Should be more than one name in the DB.");
        }

        /// <exclude/>
        [Test]
        public void TestEnums()
        {
            _enumDAO.Truncate();
            EnumClass testMe = new EnumClass();
            testMe.Enum1 = EnumTest.HERE;
            testMe.Enum2 = EnumTest.IS;
            _enumDAO.Insert(testMe);

            IList<EnumClass> enums = _enumDAO.Get();
            Assert.IsNotNull(enums, "Got null list.");
            Assert.AreEqual(1, enums.Count, "Should be one.");
            EnumClass queryResult = enums[0];
            Assert.AreEqual(testMe.Enum1, queryResult.Enum1, "Enum 1 was wrong.");
            Assert.AreEqual(testMe.Enum2, queryResult.Enum2, "Enum 2 was wrong.");

            // Now check the values in the DB are correct.
            if (_canVerifyWithSQL)
            {
                string strEnum = SqlConnectionUtilities.XSafeStringQuery((AbstractSqlConnectionDescriptor)_connDesc,
                                                                         "SELECT StringEnum FROM EnumTable", null);
                Assert.AreEqual(testMe.Enum1.ToString(), strEnum, "String enum stored wrong.");
                int intEnum = SqlConnectionUtilities.XSafeIntQuery((AbstractSqlConnectionDescriptor)_connDesc,
                                                                   "SELECT IntEnum FROM EnumTable", null);
                Assert.AreEqual((int)testMe.Enum2, intEnum, "Int enum stored wrong.");
            }
        }

        /// <exclude/>
        [Test]
        public void TestEnumsDictionary()
        {
            _enumDictDAO.Truncate();
            CheckedDictionary<string, object> testMe = new CheckedDictionary<string, object>();
            testMe["Enum1"] = EnumTest.AN;
            testMe["Enum2"] = EnumTest.ENUM;
            _enumDictDAO.Insert(testMe);

            IList<CheckedDictionary<string, object>> enums = _enumDictDAO.Get();
            Assert.IsNotNull(enums, "Got null list.");
            Assert.AreEqual(1, enums.Count, "Should be one.");
            CheckedDictionary<string, object> queryResult = enums[0];
            // DictionaryDAOs don't convert to any particular type, so you have to convert
            // when reading from them.
            Assert.AreEqual(testMe["Enum1"], Enum.Parse(typeof(EnumTest), queryResult["Enum1"].ToString()), "Enum 1 was wrong.");
            Assert.AreEqual(testMe["Enum2"], Enum.Parse(typeof(EnumTest), queryResult["Enum2"].ToString()), "Enum 2 was wrong.");

            // Now check the values in the DB are correct.
            if (_canVerifyWithSQL)
            {
                string strEnum = SqlConnectionUtilities.XSafeStringQuery((AbstractSqlConnectionDescriptor)_connDesc,
                                                                         "SELECT StringEnum FROM EnumTable", null);
                Assert.AreEqual(testMe["Enum1"].ToString(), strEnum, "String enum stored wrong.");
                int intEnum = SqlConnectionUtilities.XSafeIntQuery((AbstractSqlConnectionDescriptor)_connDesc,
                                                                   "SELECT IntEnum FROM EnumTable", null);
                Assert.AreEqual(Convert.ToInt32(testMe["Enum2"]), intEnum, "Int enum stored wrong.");
            }
        }

        /// <exclude/>
        [Test]
        public void TestBools()
        {
            _boolDAO.Truncate();
            BoolClass testMe = new BoolClass();
            testMe.ID = 100;
            testMe.BoolVal = true;
            _boolDAO.Insert(testMe);
            testMe = new BoolClass();
            testMe.ID = 200;
            testMe.BoolVal = false;
            _boolDAO.Insert(testMe);
            DaoCriteria crit = new DaoCriteria();
            SortOrder order = new SortOrder("ID", SortType.Asc);
            crit.Orders.Add(order);
            IList<BoolClass> bools = _boolDAO.Get(crit);
            Assert.IsNotNull(bools, "Got null list.");
            Assert.AreEqual(2, bools.Count, "Wrong number of records.");
            Assert.AreEqual(true, (bools[0]).BoolVal, "first was wrong.");
            Assert.AreEqual(false, (bools[1]).BoolVal, "second was wrong.");

            // Now check the values in the DB are correct.  Only need to if the DB
            // does not have a boolean type, and we're using a numeric type instead.
            if ((!_hasNativeBoolean) && (_canVerifyWithSQL))
            {
                int maxBool = SqlConnectionUtilities.XSafeIntQuery((AbstractSqlConnectionDescriptor)_connDesc, "SELECT MAX(IntBool) FROM BoolTable", null);
                Assert.AreEqual(1, maxBool, "True should have mapped to 1.");
                int minBool = SqlConnectionUtilities.XSafeIntQuery((AbstractSqlConnectionDescriptor)_connDesc, "SELECT MIN(IntBool) FROM BoolTable", null);
                Assert.AreEqual(0, minBool, "False should have mapped to 0.");
            }
        }

        /// <exclude/>
        [Test]
        public void TestBoolsDictionary()
        {
            _boolDictDAO.Truncate();
            CheckedDictionary<string, object> testMe = new CheckedDictionary<string, object>();
            testMe["ID"] = 101;
            testMe["BoolVal"] = true;
            _boolDictDAO.Insert(testMe);
            testMe = new CheckedDictionary<string, object>();
            testMe["ID"] = 201;
            testMe["BoolVal"] = false;
            _boolDictDAO.Insert(testMe);
            DaoCriteria crit = new DaoCriteria();
            SortOrder order = new SortOrder("ID", SortType.Asc);
            crit.Orders.Add(order);
            IList<CheckedDictionary<string, object>> bools = _boolDictDAO.Get(crit);
            Assert.IsNotNull(bools, "Got null list.");
            Assert.AreEqual(2, bools.Count, "Wrong number of records.");
            // DictionaryDAOs don't convert to any particular type, so you have to convert
            // when reading from them.
            Assert.AreEqual(true, Convert.ToBoolean((bools[0])["BoolVal"]), "first was wrong.");
            Assert.AreEqual(false, Convert.ToBoolean((bools[1])["BoolVal"]), "second was wrong.");

            // Now check the values in the DB are correct.  Only need to if the DB
            // does not have a boolean type, and we're using a numeric type instead.
            if ((!_hasNativeBoolean) && (_canVerifyWithSQL))
            {
                int maxBool = SqlConnectionUtilities.XSafeIntQuery((AbstractSqlConnectionDescriptor)_connDesc, "SELECT MAX(IntBool) FROM BoolTable", null);
                Assert.AreEqual(1, maxBool, "True should have mapped to 1.");
                int minBool = SqlConnectionUtilities.XSafeIntQuery((AbstractSqlConnectionDescriptor)_connDesc, "SELECT MIN(IntBool) FROM BoolTable", null);
                Assert.AreEqual(0, minBool, "False should have mapped to 0.");
            }
        }

        ///<exclude/>
        [Test]
        public void TestNullables()
        {
            PrepNullableTable();
            DaoCriteria crit = new DaoCriteria();
            SortOrder order = new SortOrder("ID", SortType.Asc);
            crit.Orders.Add(order);
            IList<NullableClass> objs = _nullDAO.Get(crit);
            Assert.IsNotNull(objs, "Got null list.");
            Assert.AreEqual(5, objs.Count, "Wrong number of records.");
            Assert.AreEqual(null, (objs[0]).BoolVal, "first bool was wrong.");
            Assert.AreEqual(true, (objs[1]).BoolVal, "second bool was wrong.");
            Assert.AreEqual(true, (objs[2]).BoolVal, "third bool was wrong.");
            Assert.AreEqual(true, (objs[3]).BoolVal, "fourth bool was wrong.");
            Assert.AreEqual(true, (objs[4]).BoolVal, "fifth bool was wrong.");
            Assert.AreEqual(null, (objs[0]).IntVal, "first int was wrong.");
            Assert.AreEqual(null, (objs[1]).IntVal, "second int was wrong.");
            Assert.AreEqual(123, (objs[2]).IntVal, "third int was wrong.");
            Assert.AreEqual(123, (objs[3]).IntVal, "fourth int was wrong.");
            Assert.AreEqual(123, (objs[4]).IntVal, "fifth int was wrong.");
            Assert.AreEqual(null, (objs[0]).DateVal, "first date was wrong.");
            Assert.AreEqual(null, (objs[1]).DateVal, "second date was wrong.");
            Assert.AreEqual(null, (objs[2]).DateVal, "third date was wrong.");
            Assert.AreEqual(new DateTime(2001, 1, 1), (objs[3]).DateVal, "fourth date was wrong.");
            Assert.AreEqual(new DateTime(2001, 1, 1), (objs[4]).DateVal, "fifth date was wrong.");
            Assert.AreEqual(null, (objs[0]).FloatVal, "first float was wrong.");
            Assert.AreEqual(null, (objs[1]).FloatVal, "second float was wrong.");
            Assert.AreEqual(null, (objs[2]).FloatVal, "third float was wrong.");
            Assert.AreEqual(null, (objs[3]).FloatVal, "fourth float was wrong.");
            Assert.AreEqual((float)4.56, (objs[4]).FloatVal, "fifth float was wrong.");
        }
        ///<exclude/>
        [Ignore("This doesn't work and don't have time to fix it right now.")]
        [Test]
        public void TestNullablesDictionary()
        {
            PrepNullDictTable();
            DaoCriteria crit = new DaoCriteria();
            SortOrder order = new SortOrder("ID", SortType.Asc);
            crit.Orders.Add(order);
            IList<CheckedDictionary<string, object>> objs = _nullDictDAO.Get(crit);
            Assert.IsNotNull(objs, "Got null list.");
            Assert.AreEqual(5, objs.Count, "Wrong number of records.");
            Assert.AreEqual(null, (objs[0])["BoolVal"], "first bool was wrong.");
            Assert.AreEqual(true, (objs[1])["BoolVal"], "second bool was wrong.");
            Assert.AreEqual(true, (objs[2])["BoolVal"], "third bool was wrong.");
            Assert.AreEqual(true, (objs[3])["BoolVal"], "fourth bool was wrong.");
            Assert.AreEqual(true, (objs[4])["BoolVal"], "fifth bool was wrong.");
            Assert.AreEqual(null, (objs[0])["IntVal"], "first int was wrong.");
            Assert.AreEqual(null, (objs[1])["IntVal"], "second int was wrong.");
            Assert.AreEqual(123, (objs[2])["IntVal"], "third int was wrong.");
            Assert.AreEqual(123, (objs[3])["IntVal"], "fourth int was wrong.");
            Assert.AreEqual(123, (objs[4])["IntVal"], "fifth int was wrong.");
            Assert.AreEqual(null, (objs[0])["DateVal"], "first date was wrong.");
            Assert.AreEqual(null, (objs[1])["DateVal"], "second date was wrong.");
            Assert.AreEqual(null, (objs[2])["DateVal"], "third date was wrong.");
            Assert.AreEqual(new DateTime(2001, 1, 1), (objs[3])["DateVal"], "fourth date was wrong.");
            Assert.AreEqual(new DateTime(2001, 1, 1), (objs[4])["DateVal"], "fifth date was wrong.");
            Assert.AreEqual(null, (objs[0])["FloatVal"], "first float was wrong.");
            Assert.AreEqual(null, (objs[1])["FloatVal"], "second float was wrong.");
            Assert.AreEqual(null, (objs[2])["FloatVal"], "third float was wrong.");
            Assert.AreEqual(null, (objs[3])["FloatVal"], "fourth float was wrong.");
            Assert.AreEqual((float)4.56, (objs[4])["FloatVal"], "fifth float was wrong.");
        }

        ///<exclude/>
        [Test]
        public void TestGroupByOne()
        {
            if (!_supportsGroupBy)
            {
                Assert.Ignore("This data source does not support aggregation / group by.");
            }
            PrepNullableTable();
            List<AbstractGroupExpression> exprs = new List<AbstractGroupExpression>();
            exprs.Add(new MemberGroupExpression("IntVal"));
            DaoCriteria crit = new DaoCriteria();
            crit.Orders.Add(new GroupCountSortOrder());
            crit.Orders.Add(new SortOrder("IntVal", SortType.Asc));
            AssertGroupByOneAscResults(_nullDAO.GetCount(crit, exprs));
        }
        ///<exclude/>
        [Test]
        public void TestGroupByOneDesc()
        {
            if (!_supportsGroupBy)
            {
                Assert.Ignore("This data source does not support aggregation / group by.");
            }
            PrepNullableTable();
            List<AbstractGroupExpression> exprs = new List<AbstractGroupExpression>();
            exprs.Add(new MemberGroupExpression("IntVal"));
            DaoCriteria crit = new DaoCriteria();
            crit.Orders.Add(new GroupCountSortOrder(SortType.Desc));
            crit.Orders.Add(new SortOrder("IntVal", SortType.Asc));
            AssertGroupByOneDescResults(_nullDAO.GetCount(crit, exprs));
        }
        ///<exclude/>
        [Test]
        public void TestGroupByOneDictionary()
        {
            if (!_supportsGroupBy)
            {
                Assert.Ignore("This data source does not support aggregation / group by.");
            }
            PrepNullDictTable();
            List<AbstractGroupExpression> exprs = new List<AbstractGroupExpression>();
            exprs.Add(new MemberGroupExpression("IntVal"));
            DaoCriteria crit = new DaoCriteria();
            crit.Orders.Add(new GroupCountSortOrder());
            crit.Orders.Add(new SortOrder("IntVal", SortType.Asc));
            AssertGroupByOneAscResults(_nullDictDAO.GetCount(crit, exprs));
        }
        ///<exclude/>
        [Test]
        public void TestGroupByOneDescDictionary()
        {
            if (!_supportsGroupBy)
            {
                Assert.Ignore("This data source does not support aggregation / group by.");
            }
            PrepNullDictTable();
            List<AbstractGroupExpression> exprs = new List<AbstractGroupExpression>();
            exprs.Add(new MemberGroupExpression("IntVal"));
            DaoCriteria crit = new DaoCriteria();
            crit.Orders.Add(new GroupCountSortOrder(SortType.Desc));
            crit.Orders.Add(new SortOrder("IntVal", SortType.Asc));
            AssertGroupByOneDescResults(_nullDictDAO.GetCount(crit, exprs));
        }
        private void AssertGroupByOneAscResults(List<GroupCountResult> results)
        {
            Assert.IsNotNull(results, "Results should not be null.");
            DumpGroupResults(results);
            Assert.AreEqual(2, results.Count, "Wrong number of results.");
            // Regardless of whether we expect nulls first, we're first sorting by count.
            Assert.AreEqual(2, results[0].Count, "Wrong number of nulls.");
            Assert.AreEqual(null, results[0].GroupValues["IntVal"], "First result had wrong value.");
            Assert.AreEqual(3, results[1].Count, "Wrong number of 123s.");
            Assert.AreEqual(123, results[1].GroupValues["IntVal"], "Second result had wrong value.");
        }
        private void AssertGroupByOneDescResults(List<GroupCountResult> results)
        {
            Assert.IsNotNull(results, "Results should not be null.");
            DumpGroupResults(results);
            Assert.AreEqual(2, results.Count, "Wrong number of results.");
            // Regardless of whether we expect nulls first, we're first sorting by count.
            Assert.AreEqual(3, results[0].Count, "Wrong number of 123s.");
            Assert.AreEqual(123, results[0].GroupValues["IntVal"], "Second result had wrong value.");
            Assert.AreEqual(2, results[1].Count, "Wrong number of nulls.");
            Assert.AreEqual(null, results[1].GroupValues["IntVal"], "First result had wrong value.");
        }

        ///<exclude/>
        [Test]
        public void TestGroupByTwo()
        {
            if (!_supportsGroupBy)
            {
                Assert.Ignore("This data source does not support aggregation / group by.");
            }
            PrepNullableTable();
            List<AbstractGroupExpression> exprs = new List<AbstractGroupExpression>();
            exprs.Add(new MemberGroupExpression("IntVal"));
            exprs.Add(new MemberGroupExpression("BoolVal"));
            DaoCriteria crit = new DaoCriteria();
            crit.Orders.Add(new GroupCountSortOrder());
            crit.Orders.Add(new SortOrder("IntVal", SortType.Asc));
            crit.Orders.Add(new SortOrder("BoolVal", SortType.Asc));
            AssertGroupByTwoResults(_nullDAO.GetCount(crit, exprs), true);
        }
        ///<exclude/>
        [Test]
        public void TestGroupByTwoDictionary()
        {
            if (!_supportsGroupBy)
            {
                Assert.Ignore("This data source does not support aggregation / group by.");
            }
            PrepNullDictTable();
            List<AbstractGroupExpression> exprs = new List<AbstractGroupExpression>();
            exprs.Add(new MemberGroupExpression("IntVal"));
            exprs.Add(new MemberGroupExpression("BoolVal"));
            DaoCriteria crit = new DaoCriteria();
            crit.Orders.Add(new GroupCountSortOrder());
            crit.Orders.Add(new SortOrder("IntVal", SortType.Asc));
            crit.Orders.Add(new SortOrder("BoolVal", SortType.Asc));
            AssertGroupByTwoResults(_nullDictDAO.GetCount(crit, exprs), _nativeBooleanReturnsAsBool);
        }
        private void AssertGroupByTwoResults(List<GroupCountResult> results, bool expectRealBool)
        {
            Assert.IsNotNull(results, "Results should not be null.");
            DumpGroupResults(results);
            Assert.AreEqual(3, results.Count, "Wrong number of results.");

            if (_expectNullsFirst)
            {
                Assert.AreEqual(1, results[0].Count, "Wrong number of null/nulls.");
                Assert.AreEqual(null, results[0].GroupValues["IntVal"], "First result had wrong int value.");
                Assert.AreEqual(null, results[0].GroupValues["BoolVal"], "First result had wrong bool value.");
                Assert.AreEqual(1, results[1].Count, "Wrong number of null/trues.");
                Assert.AreEqual(null, results[1].GroupValues["IntVal"], "Second result had wrong int value.");
                Assert.AreEqual((expectRealBool ? (object)true : 1), results[1].GroupValues["BoolVal"], "Second result had wrong bool value.");
                Assert.AreEqual(3, results[2].Count, "Wrong number of 123/trues.");
                Assert.AreEqual(123, results[2].GroupValues["IntVal"], "Third result had wrong int value.");
                Assert.AreEqual((expectRealBool ? (object)true : 1), results[2].GroupValues["BoolVal"], "Third result had wrong bool value.");
            }
            else
            {
                Assert.AreEqual(1, results[0].Count, "Wrong number of null/trues.");
                Assert.AreEqual(null, results[0].GroupValues["IntVal"], "First result had wrong int value.");
                Assert.AreEqual((expectRealBool ? (object)true : 1), results[0].GroupValues["BoolVal"], "First result had wrong bool value.");
                Assert.AreEqual(1, results[1].Count, "Wrong number of null/nulls.");
                Assert.AreEqual(null, results[1].GroupValues["IntVal"], "Second result had wrong int value.");
                Assert.AreEqual(null, results[1].GroupValues["BoolVal"], "Second result had wrong bool value.");
                Assert.AreEqual(3, results[2].Count, "Wrong number of 123/trues.");
                Assert.AreEqual(123, results[2].GroupValues["IntVal"], "Third result had wrong int value.");
                Assert.AreEqual((expectRealBool ? (object)true : 1), results[2].GroupValues["BoolVal"], "Third result had wrong bool value.");
            }
        }

        ///<exclude/>
        [Test]
        public void TestGroupByThree()
        {
            if (!_supportsGroupBy)
            {
                Assert.Ignore("This data source does not support aggregation / group by.");
            }
            PrepNullableTable();
            List<AbstractGroupExpression> exprs = new List<AbstractGroupExpression>();
            exprs.Add(new MemberGroupExpression("IntVal"));
            exprs.Add(new MemberGroupExpression("BoolVal"));
            exprs.Add(new MemberGroupExpression("DateVal"));
            DaoCriteria crit = new DaoCriteria();
            crit.Orders.Add(new GroupCountSortOrder());
            crit.Orders.Add(new SortOrder("IntVal", SortType.Asc));
            crit.Orders.Add(new SortOrder("BoolVal", SortType.Asc));
            crit.Orders.Add(new SortOrder("DateVal", SortType.Asc));
            AssertGroupByThreeResults(_nullDAO.GetCount(crit, exprs), true);
        }
        ///<exclude/>
        [Test]
        public void TestGroupByThreeDictionary()
        {
            if (!_supportsGroupBy)
            {
                Assert.Ignore("This data source does not support aggregation / group by.");
            }
            PrepNullDictTable();
            List<AbstractGroupExpression> exprs = new List<AbstractGroupExpression>();
            exprs.Add(new MemberGroupExpression("IntVal"));
            exprs.Add(new MemberGroupExpression("BoolVal"));
            exprs.Add(new MemberGroupExpression("DateVal"));
            DaoCriteria crit = new DaoCriteria();
            crit.Orders.Add(new GroupCountSortOrder());
            crit.Orders.Add(new SortOrder("IntVal", SortType.Asc));
            crit.Orders.Add(new SortOrder("BoolVal", SortType.Asc));
            crit.Orders.Add(new SortOrder("DateVal", SortType.Asc));
            AssertGroupByThreeResults(_nullDictDAO.GetCount(crit, exprs), _nativeBooleanReturnsAsBool);
        }
        private void AssertGroupByThreeResults(List<GroupCountResult> results, bool expectRealBool)
        {
            Assert.IsNotNull(results, "Results should not be null.");
            DumpGroupResults(results);
            Assert.AreEqual(4, results.Count, "Wrong number of results.");

            if (_expectNullsFirst)
            {
                Assert.AreEqual(1, results[0].Count, "Wrong number of null/nulls.");
                Assert.AreEqual(null, results[0].GroupValues["IntVal"], "First result had wrong int value.");
                Assert.AreEqual(null, results[0].GroupValues["BoolVal"], "First result had wrong bool value.");
                Assert.AreEqual(null, results[0].GroupValues["DateVal"], "First result had wrong bool value.");
                Assert.AreEqual(1, results[1].Count, "Wrong number of null/trues.");
                Assert.AreEqual(null, results[1].GroupValues["IntVal"], "Second result had wrong int value.");
                Assert.AreEqual((expectRealBool ? (object)true : 1), results[1].GroupValues["BoolVal"], "Second result had wrong bool value.");
                Assert.AreEqual(null, results[1].GroupValues["DateVal"], "Second result had wrong bool value.");
                Assert.AreEqual(1, results[2].Count, "Wrong number of 123/trues.");
                Assert.AreEqual(123, results[2].GroupValues["IntVal"], "Third result had wrong int value.");
                Assert.AreEqual((expectRealBool ? (object)true : 1), results[2].GroupValues["BoolVal"], "Third result had wrong bool value.");
                Assert.AreEqual(null, results[2].GroupValues["DateVal"], "Third result had wrong bool value.");
                Assert.AreEqual(2, results[3].Count, "Wrong number of 123/trues.");
                Assert.AreEqual(123, results[3].GroupValues["IntVal"], "Fourth result had wrong int value.");
                Assert.AreEqual((expectRealBool ? (object)true : 1), results[3].GroupValues["BoolVal"], "Fourth result had wrong bool value.");
                Assert.AreEqual(new DateTime(2001, 1, 1), results[3].GroupValues["DateVal"],
                                "Fourth result had wrong bool value.");
            }
            else
            {
                Assert.AreEqual(1, results[0].Count, "Wrong number of 123/true/nulls.");
                Assert.AreEqual(123, results[0].GroupValues["IntVal"], "First result had wrong int value.");
                Assert.AreEqual((expectRealBool ? (object)true : 1), results[0].GroupValues["BoolVal"], "First result had wrong bool value.");
                Assert.AreEqual(null, results[0].GroupValues["DateVal"], "First result had wrong bool value.");
                Assert.AreEqual(1, results[1].Count, "Wrong number of null/true/nulls.");
                Assert.AreEqual(null, results[1].GroupValues["IntVal"], "Second result had wrong int value.");
                Assert.AreEqual((expectRealBool ? (object)true : 1), results[1].GroupValues["BoolVal"], "Second result had wrong bool value.");
                Assert.AreEqual(null, results[1].GroupValues["DateVal"], "Second result had wrong bool value.");
                Assert.AreEqual(1, results[2].Count, "Wrong number of null/null/nulls.");
                Assert.AreEqual(null, results[2].GroupValues["IntVal"], "Third result had wrong int value.");
                Assert.AreEqual(null, results[2].GroupValues["BoolVal"], "Third result had wrong bool value.");
                Assert.AreEqual(null, results[2].GroupValues["DateVal"], "Third result had wrong bool value.");
                Assert.AreEqual(2, results[3].Count, "Wrong number of 123/true/Dates.");
                Assert.AreEqual(123, results[3].GroupValues["IntVal"], "Fourth result had wrong int value.");
                Assert.AreEqual((expectRealBool ? (object)true : 1), results[3].GroupValues["BoolVal"], "Fourth result had wrong bool value.");
                Assert.AreEqual(new DateTime(2001, 1, 1), results[3].GroupValues["DateVal"],
                                "Fourth result had wrong bool value.");
            }
        }

        private void DumpGroupResults(List<GroupCountResult> results)
        {
            foreach (GroupCountResult result in results)
            {
                Console.WriteLine(result.Count + StringHelper.Join(result.GroupValues));
            }
        }

        private void PrepNullableTable()
        {
            _nullDAO.Truncate();
            NullableClass testMe = new NullableClass();
            testMe.ID = 100;
            _nullDAO.Insert(testMe);
            testMe.ID = 101;
            testMe.BoolVal = true;
            _nullDAO.Insert(testMe);
            testMe.ID = 102;
            testMe.IntVal = 123;
            _nullDAO.Insert(testMe);
            testMe.ID = 103;
            DateTime testDate = new DateTime(2001, 1, 1);
            testMe.DateVal = testDate;
            _nullDAO.Insert(testMe);
            testMe.ID = 104;
            testMe.FloatVal = (float)4.56;
            _nullDAO.Insert(testMe);
            DaoCriteria crit = new DaoCriteria();

        }

        private void PrepNullDictTable()
        {
            _nullDictDAO.Truncate();
            CheckedDictionary<string, object> testMe = new CheckedDictionary<string, object>();
            testMe["ID"] = 110;
            _nullDictDAO.Insert(testMe);
            testMe["ID"] = 111;
            testMe["BoolVal"] = true;
            _nullDictDAO.Insert(testMe);
            testMe["ID"] = 112;
            testMe["IntVal"] = 123;
            _nullDictDAO.Insert(testMe);
            testMe["ID"] = 113;
            DateTime testDate = new DateTime(2001, 1, 1);
            testMe["DateVal"] = testDate;
            _nullDictDAO.Insert(testMe);
            testMe["ID"] = 114;
            testMe["FloatVal"] = (float)4.56;
            _nullDictDAO.Insert(testMe);
        }
    }

    /// <exclude/>
    public class NameClass
    {
        /// <exclude/>
        public int ID;
        /// <exclude/>
        public string Name;
        /// <exclude/>
        public NameClass()
        {
        }
        /// <exclude/>
        public NameClass(string name)
        {
            Name = name;
        }
    }

    /// <exclude/>
    public enum EnumTest
    {
        /// <exclude/>
        HERE,
        /// <exclude/>
        IS,
        /// <exclude/>
        AN,
        /// <exclude/>
        ENUM
    }

    /// <exclude/>
    public class EnumClass
    {
        /// <exclude/>
        public int ID;
        /// <exclude/>
        public EnumTest Enum1;
        /// <exclude/>
        public EnumTest Enum2;
    }

    /// <exclude/>
    public class BoolClass
    {
        /// <exclude/>
        public int ID;
        /// <exclude/>
        public bool BoolVal;
    }

    /// <exclude/>
    public class NullableClass
    {
        /// <exclude/>
        public int ID;
        /// <exclude/>
        public bool? BoolVal;
        /// <exclude/>
        public int? IntVal;
        /// <exclude/>
        public DateTime? DateVal;
        /// <exclude/>
        public float? FloatVal;
    }
}